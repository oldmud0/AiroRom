% Copyright (c) 2015 Benito Palacios Sánchez - All Rights Reserved.
% Esta obra está licenciada bajo la Licencia Creative Commons Atribución 4.0
% Internacional. Para ver una copia de esta licencia, visita
% http://creativecommons.org/licenses/by/4.0/.

\chapter{Metodología}
\label{sec:met}
Este capítulo se centrará en explicar las diferentes metodologías, técnicas y programas que se han usado durante el desarrollo del proyecto.
No existe un único método cuando se realiza un trabajo de ingeniería inversa ya que cada juego es distinto, con formatos diferentes.
Debido a esto, en lugar de proporcionar unos pasos exactos, se detallarán los razonamientos seguidos a la hora de estudiar ficheros y analizar código.


\section{Análisis de ficheros}
Una vez decidido el juego a analizar, se debe reunir información como el desarrollador, el año de lanzamiento y género del juego.
Esta proporciona indicios sobre el tipo y versión del formato de los ficheros que contiene.
Usando programas de exploración de juegos como Tinke\footnote{\url{https://github.com/pleonex/tinke}}, se pueden reconocer los tipos de formato estándar, analizar el contenido de las carpetas y exportar los archivos.

El interés sin embargo es analizar aquellos formatos nuevos, que codifican recursos como imágenes y textos.
Los nombres y directos de los archivos son la primera referencia sobre el tipo de contenido.
Por ejemplo, tomando el juego de \textit{Ninokuni} para \acl{NDS}, el archivo \texttt{/data/UI/Menu/Skin/2/CheckShee\allowbreak{}t/bg\_a.n2d} debe contenido elementos de la interfaz gráfica (\textit{UI}) del menú (\textit{Menu}) del juego.
Además, la abreviatura \textit{bg} se utiliza para describir imágenes de fondo de pantalla (\textit{background}).
Mirando el contenido de este archivo con un visor hexadecimal se puede ver en la posición \texttt{0x54} se encuentran los caracteres \texttt{RLCN}, correspondientes a la cabecera de un formato estándar en la \acl{NDS} (Figura~\ref{fig:met-bg1}).

\includefigure{fig:met-bg1}{Contenido de un fichero con imágenes de \textit{Ninokuni}.}{imgs/MET-Bg1.png}

Encontrar esta cabecera indica que este archivo contiene varios ficheros, en un formato similar a \texttt{zip}.
El análisis se centraría en saber cómo extraer los ficheros para luego determinar qué datos tienen cada uno de ellos.
Se parte sabiendo que la posición del primer fichero es \texttt{0x54}, por lo que se buscará este valor en la cabecera del formato.
En la posición \texttt{0x0C}, se observa justo ese valor, seguido de \texttt{0x228}.
Frecuentemente, después de la posición de un fichero se indica su tamaño, por lo que habrá que comprobar si el primer fichero termina en la posición \verb!0x54 + 0x228 = 0x27C!. En la Figura~\ref{fig:met-bg2} se ve que en esa posición aparece la cabecera \texttt{RGCN}, estándar para otro formato de archivo.

\includefigure{fig:met-bg2}{Contenido de un fichero comprimido de \textit{Ninokuni}.}{imgs/MET-Bg2.png}

Esto corrobora la estructura que se intuía, por lo que por cada fichero hay 8 bytes indicando posición y tamaño.
Para determinar el número de ficheros se puede calcular cuantos archivos especifica esa \textit{tabla de contenidos}, restando el principio del primer fichero a la posición de la primera entrada y diviendo por el número de bytes dedicado a cada fichero: \verb!(0x54 - 0x0C) / 0x08 = 9!.
El resultado es que se han especificado 9 ficheros, valor que coincide con el encontrado en la posición \texttt{0x08} (Figura~\ref{fig:met-bg1}).

Esta forma de razonar es la que se ha empleado para averiguar de los formatos estudiados en el trabajo.
Faltaría averiguar el contenido de cada fichero.
Estudiando los formatos más comunes, se puede identificar (Figura~\ref{fig:met-bg2}) que al principio hay colores, pues cada valor de 16 bits está próximo al siguiente.
Al final hay información sobre cada píxel, índice al color de la paleta, pues se repiten muchos valores que están próximos, esto concuerda con el hecho de que un píxel en una imagen suele tener a su alrededor píxeles de color similar.

Otro ejemplo se encuentra en los archivos de tipo \texttt{PSAR} (Figura~\ref{fig:met-psar}) analizados en la Sección~\ref{sec:cr-nino}.
En ellos, en la posición \texttt{0x08}, mediante los caracteres \texttt{ASCII} se indica el tipo de compresión que se usa sobre los datos, \texttt{zlib}.

\begin{figure}[bh]
\centering
\includegraphics{imgs/CR-PSAR.png}
\caption{Primeros bytes del fichero \texttt{PSAR}.}
\label{fig:met-psar}
\end{figure}

\section{Depuración de código}
En ocasiones, el análisis de un fichero hexadecimal no es suficiente para estudiar un formato.
Este es el caso de codificaciones complejas y estudios de cifrado e integridad en los que hace falta mirar la implementación del juego.
En estos casos, mediante depuración del juego se pueden analizar las instrucciones máquina que ejecuta la consola, para saber cómo procesa el juego los ficheros y así poder estudiarlos.
La depuración de juegos de \acl{NDS} se puede realizar utilizando dos programas  (Figura~\ref{fig:met-dep}).

\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=.4\linewidth]{imgs/MET-IDAPro.png}
    \caption{IDA Pro 6.1 con DeSmuME.}
\label{fig:met-idapro}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=.4\linewidth]{imgs/MET-Nosgba.png}
    \caption{Emulador con depurador integrado No\$GBA.}
\label{fig:met-nosgba}
\end{subfigure}
\caption{Programas para depurar juegos de \acl{NDS}.}
\label{fig:met-dep}
\end{figure}

El primer método es usar el emulador DeSmuME y el depurador IDA Pro.
Este emulador se puede compilar activando funciones de depuración remotas.
Incluye una implementación de \textit{GDB Remote Serial Protocol}\footnote{\url{http://www.embecosm.com/appnotes/ean4/embecosm-howto-rsp-server-ean4-issue-2.html}} que permite que programas externos controlen la ejecución del juego paso a paso y accedan a la memoria \texttt{RAM}.
Esto es lo que hace IDA Pro, sirviendo como un depurador universal.
De esta forma se puede visualizar el código en ensamblador, poner puntos de interrupición y ver y cambiar la memoria del juego.

La alternativa es usar el emulador privativo No\$GBA.
Existe una versión que incluye un depurador, originalmente de pago, pero que recientemente se liberó como \textit{freeware}.
Incluye las mismas funciones descritas anteriormente, pero en este caso implementandas sobre el propio emulador, aumentando la eficiencia.

Dado que IDA Pro es un programa con una licencia básica de \$500, este trabajo se realizó con el emulador No\$GBA que a pesar de no tener tantas funcionalidad, sí provee de las necesarias para realizar el trabajo.

\subsection{Búsqueda de archivos en RAM}
Esta subsección explicará el procedimiento seguido para, mediante depuración, averiguar cómo el juego procesa un fichero.
Para ello, hace falta conocer cómo el juego obtiene datos del cartucho del juego.
El protocolo de comunicación es sencillo, cuando se necesitan datos se envía un comando, que el hardware cifra (esa parte, al usar un emulador, no se realiza), y al cual al cartucho responde con los datos solicitados.
El código de este comando es \texttt{0xB7} y se envía escribiéndolo en el puerto virtual \texttt{0x040001A8}~\cite{GbaTek}.

Conociendo la función de código que se encarga de envíar este comando, solicitando bloques de datos, y poniendo un punto de interrupción, de forma que la ejecución del juego se para pudiendo ver qué dirección se ha solicitado, se podría determinar qué archivo acaba de ser solicitado.
Dado que continuamente se están cargando datos, realizar esto manualmente no es viable, es por ello, que aprovechando que el emulador DeSmuME es de código abierto, se puede modificar para automatizarlo.

Esta mecánica se implementó para realizar los análisis de este trabajo con el programa \textit{NitroFilcher}\footnote{\url{https://github.com/pleonex/AiroRom/tree/master/Programs/NitroFilcher}}.
En el emulador se añadieron las siguientes líneas de código a la función \texttt{HandleDebugEvent\_Execute} del archivo \texttt{debug.cpp}, consiguiendo que cada vez que se ejecutara las instrucciones que solicitan datos, guardase en un fichero de texto la posición que se pedía junto al tamaño.

\begin{verbatim}
// 0x02016DE0 es la dirección de la función que solicita datos.
if (DebugEventData.addr == 0x02016DE0 && log_ptr != NULL) {
    u32 addr = DebugEventData.cpu()->R[2];
    u32 size = DebugEventData.cpu()->R[3];
    fprintf(log_ptr, "%08X,%08X,%08X\n", addr, size, addr + size);
}
\end{verbatim}

Este fichero luego lo procesaría el programa \textit{NitroFilcher}, escribiendo en otro fichero de texto las rutas a los archivos que correspondían esas direcciones.

\subsection{Búsqueda de algoritmos sobre textos}
\label{sec:met-search-text}
En el Capítulo~\ref{sec:translations} se mostrarán algoritmos para ofuscar y cifrar textos.
El procedimiento para realizar este estudio se basa en depuración de código.

El primer paso es buscar la frase en texto plano sobre el binario del juego.
Tras determinar que no aparece, se puede confirmar que puede estar codificada en una codificación no estándar, comprimida o cifrada.
Se suele probar con las codificaciones soportadas nativamente por las fuentes de \acl{NDS} como son \texttt{UTF-8}, \texttt{UTF-16}, \texttt{SHIFT-JIS} y \texttt{CP1252}.

Confirmado que hay un algoritmo que se aplica sobre el texto, el objetivo es encontrar este texto en la memoria \texttt{RAM} del juego, para poder poner un punto de interrupción y ver qué transformaciones se aplican hasta llegar al texto descifrado.
Para ello, se extrae la memoria, justo en el momento de mostrar ese diálogo, pues debería estar la frase guardad para poder mostrarla en pantalla.
Esto se puede realizar con cualquier emulador de \acl{NDS}.
Una vez extraído el archivo binario con la memoria, mediante visores hexadecimales se busca el texto usando de nuevo codificaciones estándar.
Si la frase se encuentra, se pondría un punto de interrupción en dicha posición y se estudiaría el algoritmo.
En caso contrario, probablemente se use una codificación propietaria, sin embargo se puede encontrar siguiendo la metodología explicada en los siguientes apartados.

\subsubsection{Búsqueda de la tipografía}
El primero consiste en buscar el archivo con la tipografía del juego, pues la codificación será la misma que el orden con el que aparecen los caracteres en ella.
El estandar de este formato tiene la cabecera \texttt{NTFR} y existen programas para extraer y editar este tipo de formatos\footnote{\url{https://github.com/pleonex/NerdFontTerminatoR}}.

\subsubsection{Búsqueda diferencial}
El segundo procedimiento se trata de desarrollar un programa de búsqueda diferencial.
Una implementación se llevó a cabo para este estudio, denominado \textit{RelativeSearch} y disponible en el repositorio del trabajo\footnote{\url{https://github.com/pleonex/RelativeSearch}}.

La ídea de este programa se basa en que un grupo de caracteres similares, tiene una numeración seguida.
Por ejemplo, si la codificación indica que el carácter `a' tiene asociado el valor \texttt{0x0123}, el carácter `b' tendrá el siguiente, \texttt{0x0124}.
Restando ambos valores, se encuentra su `distancia' en el abecedario.
Esta distancia, en la mayoría de los casos, será la misma en cualquier codificación, incluso propietaria, a no ser que se hayan desordenado los caracteres.

\textit{RelativeSearch} (Figura~\ref{fig:met-relative}), implementa esta idea, para ello dada una palabra como `hola', resta cada carácter sobre el anterior y guarda esa diferencia.
A continuación, sobre un fichero binario, realiza esta misma operación, resta un byte sobre el anterior y compara la diferencia.
Si la diferencia coincide, se muestra en pantalla la posición de la coincidencia.
El programa soporta la búsqueda de codificaciones de 8 y 16 bits.

\includefigure{fig:met-relative}{Frase con codificación no estándar encontrada por RelativeSearch en \textit{Pokémon}.}{imgs/MET-Relative.png}

\subsection{Búsqueda de algoritmo sobre imágenes}
\label{sec:met-search-img}
El procedimiento para encontrar el algoritmo de cifrado en este caso es distinto al realizado con texto.
No se puede partir de datos conocidos como anteriormente se hacía con una frase que se veía en la pantalla.
Sin embargo, dado que las cabeceras de la imagen suelen ser estandar, se puede buscar sobre el código en ensamblador la función que procesa esta cabecera.
En concreto se busca el identificador \texttt{CHAR}, que se procesa para determinar el comienzo de una sección del archivo.

Una vez encontrada la función que lee una imagen, se puede poner un punto de interrupción sobre ella, para tener acceso a los datos cifrados cuando el juego procese un archivo.
Una vez localizados, se ponde un punto de interrupción sobre ellos, este último, llevará al código que procesa estos datos, por tanto el algoritmo que los descifra.

\section{Intercepción de comunicación}
\label{sec:met-nds-desmume}
La \acl{NDS} fue la primera portátil de Nintendo en soportar servicios en línea mediante una conexión Wi-Fi.
Esta comunicación se ha estudiado en el Capítulo~\ref{sec:multiplayer}.
En esta sección se explicará la metodología seguida para capturar los paquetes.

Para ello se preparó un escenario para realizar un ataque \textit{man-in-the-middle}.
Un punto de acceso adicional se conectó al ordenador mediante \textit{Ethernet} y este a su vez mediante conexión Wi-Fi con el punto de acceso original.
Dado que el sistema operativo \textit{Fedora 20} por defecto tiene una configuración restrictiva de red, se tuvo que diseñar el siguiente \textit{script} para configurar una subred mediante \textit{NAT} y permitir el redireccionamiento de paquetes.

\begin{verbatim}
# El primer argumento es la IP de la interfaz que tiene conexión a Internet
# Crea la ruta hacia la subred
sudo route add -net 192.168.3.0/24 gw 10.42.0.29 p35p1

# Habilita SNAT para la segunda subred
sudo iptables -t nat -I POSTROUTING -s 192.168.3.0/24 -o wlp4s0 -j SNAT --to $1

# Permite los paquetes de destino la segunda subred
sudo iptables -t filter -I FORWARD -d 192.168.3.0/24 -j ACCEPT

# Permite los paquetes con origen la segunda subred
sudo iptables -t filter -I FORWARD -s 192.168.3.0/24 -j ACCEPT

# Permite sin restricción los paquetes con destino la primera subred
sudo iptables -t filter -I FORWARD -d 10.42.0.0/24 -j ACCEPT
\end{verbatim}

Usando \textit{Wireshark} para capturar los paquetes sobre la interfaz de \textit{Ethernet} se pudo capturar todo el tráfico.
Este escenario requería hardware y era complejo de cada vez que se quería analizar un juego.
Es por ello, que aprovechando que el emulador DeSmuME soporta las comunicaciones Wi-Fi y es de código libre, se modificó para guardar los datos que transmitía y enviaba en formato \textit{PCAP}, compatible con \textit{Wireshark}.

Se modificaron los archivos \texttt{wifi.cpp} y \texttt{wifi.h}\footnote{\url{https://github.com/pleonex/AiroRom/tree/master/Programs/DeSmuME\%20PCAP}}, añadiendo los siguientes métodos:

\begin{itemize}
    \item \verb!create_packet()!: inicializa un nuevo archivo \texttt{PCAP} para guardar los datos.
    Esta función se llama cada vez que se realiza una petición de asociación con el punto de acceso, es decir, cuando se inicia una conexión.

    \item \verb!save_packet(u8* packet, u32 len)!: guarda un paquete \textit{Ethernet} en el archivo.

    \item \verb!save_adhocPacket(u8* packet, u32 len, void* addrGen, bool isSent)!: genera un paquete con cabeceras \textit{Ethernet}, \textit{IP} y \textit{UDP} y guarda los datos de la capa aplicación que se le pasa.
    Esta función se llama cuando se envía un paquete mediante comunicación \textit{ad-hoc} a otra consola.
    Dado que este paquete, solo contiene datos en formato del protocolo de Nintendo, para poder analizarlo con \textit{Wireshark} es necesario crear las cabeceras de la capa de enlace, red y transporte.
\end{itemize}

Esta comunicación sin embargo está cifrada.
En la Sección~\ref{sec:mp-nintendo-server} sobre los resultados de los servicios en línea de Nintendo, se explica cómo utilizar los programas desarrollados \textit{RC4Finder} y \textit{SSLPatcher} para capturar una comunicación descifrada de la \acl{NDS}.

\section{Documentación y repositorio}
Los programas y documentación de este trabajo se ha ido publicando en un repositorio, gestionado por \textit{git}, y subido a la página \textit{GitHub}, con el siguiente enlace:

\begin{center}
\url{https://github.com/pleonex/AiroRom}\footnote{El nombre \textit{AiroRom} es un juego de palabras entre \textit{airo}, del junto de herramientas \textit{aircrack} y \textit{ROM}, que es como se denomina al archivo de un videojuego.}
\end{center}

La documentación se fue redactando en formato \textit{Markdown} en la wiki\footnote{\url{https://github.com/pleonex/AiroRom/wiki}} del repositorio.
En la página de \textit{Mecanismos a investigar}, se muestran los juegos ordenados por desarrollador con más juegos lanzados.
Para crear esta clasificación se hizo el \textit{script} en \textit{python} llamado \textit{Scenadvorter}.
Este programa, lee un XML con una base de datos de todos los juegos para \acl{NDS} que proporciona la página ADVANsCEne\footnote{\url{http://www.advanscene.com}}, y clasifica los juegos por desarrollador mostrando los diez primeros con más juegos.

Para guardar la información sobre los algoritmos descubiertos, se desarrolló un programa que permitía guardar y editar dicha información en ficheros XML.
Este programa (Figura~\ref{fig:met-databrithm}) se llamó \textit{DataBrithm} y se encuentra todo su código en el repositorio también.

\includefigure{fig:met-databrithm}{Programa de gestión de algoritmos de juegos DataBrithm}{imgs/MET-DataBrithm.png}

En la carpeta \texttt{Games} del repositorio se encuentran programas y enlaces a repositorios con programas desarrollados para analizar los contenidos de cuatro juegos.
De forma similar, en la carpeta \texttt{Programs}, se incluye enlace a los repositorios y programas desarrollados para el análisis.
Finalmente, dentro de \texttt{Report} se encuentra esta memoria, realizada con \LaTeX~\cite{ThesisTex}.
