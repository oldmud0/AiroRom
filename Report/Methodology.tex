% Copyright (c) 2015 Benito Palacios Sánchez - All Rights Reserved.
% Esta obra está licenciada bajo la Licencia Creative Commons Atribución 4.0
% Internacional. Para ver una copia de esta licencia, visita
% http://creativecommons.org/licenses/by/4.0/.

\chapter{Metodología}
\label{sec:met}
Este capítulo explicará las diferentes metodologías llevadas a cabo durante la realización del proyecto.
No existe un método único a la hora de realizar un trabajo de ingeniería inversa, cada juego es diferente, programado por diferentes compañías en distintos instantes de tiempo.
Al trabajar con formatos, estos van evolucionando, añadiendo más campos o siendo reemplazados por nuevos con mayor funcionalidad.
Analizando instrucciones máquina, estas cambian en cada compilación del juego, especialmente los registros usados.
Aunque la funcionalidad del código sea la misma, problablemente no se usen los mismos registros, valores de pila, haciendo difícil poder reconocer un mismo algoritmo en dos juegos distintos.

El objetivo de las siguiente secciones es mostrar qué técnicas, programas y pasos se han realizado a la hora de analizar los juegos de este trabajo.
Apartir de ellos, y con pequeñas modificaciones, se pueden analizar aspectos de seguridad para otro conjunto de videojuegos.

\section{Análisis de ficheros}
Una vez decidido un juego objetivo se debe reunir información sobre él.
Conocer el desarrollador, el año de lanzamiento y género del juego pueden ser útiles pues, proporcionan indicios sobre el tipo de ficheros que contiene.
Usando programas de exploración de ficheros como Tinke\footnote{\url{https://github.com/pleonex/tinke}}, se pueden reconocer los tipos de formato estándar y comenzar a trabajar sobre ellos.

El interés sin embargo es analizar aquellos formatos nuevos, que codifican recursos como imágenes y textos.
Los nombres y directos de los archivos son la primera referencia sobre el tipo de contenido.
Por ejemplo, tomando el juego de \textit{Ninokuni} para \acl{NDS}, el archivo \texttt{/data/UI/Menu/Skin/2/CheckShee\allowbreak{}t/bg\_a.n2d} debe contenido elementos de la interfaz gráfica (\textit{UI}) del menú (\textit{Menu}) del juego.
Además, la abreviatura \textit{bg} se utiliza para describir imágenes de fondo de pantalla (\textit{background}).
Mirando el contenido de este archivo con un visor hexadecimal se puede ver en la posición \texttt{0x54} se encuentran los caracteres \texttt{RLCN}, correspondientes a la cabecera de un formato estándar en la \acl{NDS} (Figura~\ref{fig:met-bg1}).

\includefigure{fig:met-bg1}{Contenido de un fichero con imágenes de \textit{Ninokuni}.}{imgs/MET-Bg1.png}

Al contrar esa cabecera, indica que este archivo contiene varios ficheros, en un formato similar a \texttt{zip}.
El análisis se centraría en saber cómo extraer los ficheros para luego determinar qué datos tienen cada uno de ellos.
Como dato indicativo se tiene que los datos del primer fichero empiezan en la posición \texttt{0x54}, por lo que habrá que buscar un valor qué indique esta posición.
En la posición \texttt{0x0C}, se observa justo ese valor, seguido de \texttt{0x228}.
Frecuentemente, después de la posición de un fichero se indica su tamaño, por lo que habrá que comprobar si el primer fichero termina en la posición \verb!0x54 + 0x228 = 0x27C!. En la Figura~\ref{fig:met-bg2} se ve que en esa posición aparece la cabecera \texttt{RGCN}, estándar para otro formato de archivo.

\includefigure{fig:met-bg2}{Contenido de un fichero comprimido de \textit{Ninokuni}.}{imgs/MET-Bg2.png}

Esto corrobora la estructura que se intuía, por lo que por cada fichero hay 8 bytes indicando posición y tamaño.
Para determinar el número de ficheros se puede calcular cuantos archivos especifica esa \textit{tabla de contenidos}, restando el principio del primer fichero a la posición de la primera entrada y diviendo por el número de bytes dedicado a cada fichero: \verb!(0x54 - 0x0C) / 0x08 = 9!.
El resultado es que se han especificado 9 ficheros, valor que coincide con el encontrado en la posición \texttt{0x08} (Figura~\ref{fig:met-bg1}).

Esta forma de razonar es la que se ha empleado para averiguar de los formatos estudiados en el trabajo.
Faltaría averiguar el contenido de cada fichero.
Estudiando los formatos más comunes, se puede identificar (Figura~\ref{fig:met-bg2}) que al principio hay colores, pues cada valor de 16 bits está próximo al siguiente.
Al final hay información sobre cada píxel, índice al color de la paleta, pues se repiten muchos valores que están próximos, esto concuerda con el hecho de que un píxel en una imagen suele tener a su alrededor píxeles de similar color.

Otro ejemplo se encuentra en los archivos de tipo \texttt{PSAR} (Figura~\ref{fig:met-psar}) analizados en la Sección~\ref{sec:cr-nino}.
En ellos, en la posición \texttt{0x08}, mediante los caracteres \texttt{ASCII} se indica el tipo de compresión que se usa sobre los datos, \texttt{zlib}.

\begin{figure}[bh]
\centering
\includegraphics{imgs/CR-PSAR.png}
\caption{Primeros bytes del fichero \texttt{PSAR}.}
\label{fig:met-psar}
\end{figure}

\section{Depuración de código}

% Debate entre ida y no5gba con captura

% TODO: Boku y hebras GZIP

\subsection{Búsqueda de archivos en RAM}
% Explicar trauma center

\subsection{Búsqueda de algoritmos sobre textos}
\label{sec:met-search-text}
% TODO:
En el Capítulo~\ref{sec:translations} se mostrarán algoritmos para ofuscar y cifrar textos.
El procedimiento para realizar este estudio se basa tanto en depuración de código, como en el conocimiento de malas prácticas empleadas.

El primer paso consiste en mirar el archivo cifrado y realizar un estudio de los bytes más frecuentes.
Tras una búsqueda de las frases de diálogos iniciales sobre todo el archivo binario del juego no se encuentran resultados.
Se probó en las codificaciones más frecuentes de esta consola como son ASCII y UNICODE sin resultado.
Esto indica que bien el archivo que contiene los textos está comprimido o cifrado.

El siguiente procedimiento fue extraer la memoria RAM del juego justo en el momento de mostrar ese diálogo, pues debería estar almacenada esa frase para poder ser mostrada en pantalla.
Esto se puede realizar gracias al emulador DeSmuME.
Una vez extraído el archivo binario con la memoria RAM, mediante visores hexadecimales se buscó la frase que aparecía en pantalla usando las codificaciones estándar y sin obtener resultado de nuevo.
Dado que la frase ha de estar en la memoria RAM, el problema era por tanto que no estaba usando una codificación estándar.
Existen dos procedimientos básicos para realizar una búsqueda en estos casos.

El primero consiste en buscar el archivo con la tipografía del juego, pues la codificación será la misma que el orden con el que aparecen los caracteres en ella.

El segundo procedimiento posible es el de desarrollar un programa de búsqueda diferencial. Con motivo de este trabajo se explica el programa \textit{RelativeSearch} que se llevó a cabo. Este tipo de software se puede usar siempre y cuando el orden de los caracteres de un mismo grupo (por ejemplo letras minúsculas) corresponda a estándares como ASCII. Si se hubiese seguido un orden aleatorio en la codificación propietaria este no serviría quedando la primera opción como única alternativa.

Tras usar cualquiera de los dos procedimientos anteriormente descritos, se puedo encontrar una coincidencia en la memoria RAM del diálogo. El siguiente paso consistió en depurar el juego para hallar el algoritmo de descifrado o descompresión de textos. Para ello usando los programas de depuración, se puso un punto de interrupción en dicha posición.

Cabe destacar que esta posición es dinámica por lo que cambia cada vez que se inicia el juego pues depende de muchas variables. Para sortear este problema se hizo uso de los \textit{savestates} del emulador, es decir guardados de memoria del juego que permiten ir a cualquier momento de una ejecución. Gracias a esta característica se puede realizar un guardado justo antes de que el juego guarde un juego de forma que siempre que se use ese \textit{savestate} encontraremos el texto en la misma posición. El punto de interrupción hizo parar el emulador justo en las instrucciones máquinas que estaban realizando, en este caso, el descifrado.

\subsection{Búsqueda de algoritmo sobre imágenes}
\label{sec:met-search-img}
El procedimiento para encontrar el algoritmo de cifrado en este caso es distinto al realizado con texto.
No se puede partir de datos conocidos como anteriormente se partía de una frase que se veía en la pantalla.
Sin embargo, dado que las cabeceras de la imagen no están cifradas se pudo buscar sobre el código en ensamblador la función que procesa esta cabecera.
En concreto se buscó la palabra mágica \texttt{CHAR} que se procesa para determinar el comienzo de una sección del archivo.

Una vez encontrado la función que lee una imagen, solo habría que acceder a una parte del juego donde se esperaba que se cargase una imagen como durante una batalla y poner un punto de interrupción sobre esta función.
Tras omitir imágenes que no estaban cifradas\footnote{Dado que una imagen contiene suele tener píxeles cercanos de igual colores, siempre que en los datos se observara patrones se podía determinar que no estaba cifrada.}, se llegó a una que sí lo estaba donde se puso un punto de interrupción.

\section{Intercepción de comunicación}
\label{sec:met-nds-desmume}
% explicar desmume modificado para guardar datos

% explicar rc4finder

% explicar sslpatcher

\section{Documentación}

% Explicar databrithm

% Comentar programas de los juegos

% explicar script de organización
