% Copyright (c) 2015 Benito Palacios Sánchez - All Rights Reserved.
% Esta obra está licenciada bajo la Licencia Creative Commons Atribución 4.0
% Internacional. Para ver una copia de esta licencia, visita
% http://creativecommons.org/licenses/by/4.0/.

\chapter{Metodología}
\label{sec:met}
Este capítulo explicará las diferentes metodologías llevadas a cabo durante la realización del proyecto.
No existe un método único a la hora de realizar un trabajo de ingeniería inversa, cada juego es diferente, programado por diferentes compañías en distintos instantes de tiempo.
Al trabajar con formatos, estos van evolucionando, añadiendo más campos o siendo reemplazados por nuevos con mayor funcionalidad.
Analizando instrucciones máquina, estas cambian en cada compilación del juego, especialmente los registros usados.
Aunque la funcionalidad del código sea la misma, problablemente no se usen los mismos registros, valores de pila, haciendo difícil poder reconocer un mismo algoritmo en dos juegos distintos.

El objetivo de las siguiente secciones es mostrar qué técnicas, programas y pasos se han realizado a la hora de analizar los juegos de este trabajo.
Apartir de ellos, y con pequeñas modificaciones, se pueden analizar aspectos de seguridad para otro conjunto de videojuegos.

\section{Análisis de ficheros}
Una vez decidido un juego objetivo se debe reunir información sobre él.
Conocer el desarrollador, el año de lanzamiento y género del juego pueden ser útiles pues, proporcionan indicios sobre el tipo de ficheros que contiene.
Usando programas de exploración de ficheros como Tinke\footnote{\url{https://github.com/pleonex/tinke}}, se pueden reconocer los tipos de formato estándar y comenzar a trabajar sobre ellos.

El interés sin embargo es analizar aquellos formatos nuevos, que codifican recursos como imágenes y textos.
Los nombres y directos de los archivos son la primera referencia sobre el tipo de contenido.
Por ejemplo, tomando el juego de \textit{Ninokuni} para \acl{NDS}, el archivo \texttt{/data/UI/Menu/Skin/2/CheckShee\allowbreak{}t/bg\_a.n2d} debe contenido elementos de la interfaz gráfica (\textit{UI}) del menú (\textit{Menu}) del juego.
Además, la abreviatura \textit{bg} se utiliza para describir imágenes de fondo de pantalla (\textit{background}).
Mirando el contenido de este archivo con un visor hexadecimal se puede ver en la posición \texttt{0x54} se encuentran los caracteres \texttt{RLCN}, correspondientes a la cabecera de un formato estándar en la \acl{NDS} (Figura~\ref{fig:met-bg1}).

\includefigure{fig:met-bg1}{Contenido de un fichero con imágenes de \textit{Ninokuni}.}{imgs/MET-Bg1.png}

Al contrar esa cabecera, indica que este archivo contiene varios ficheros, en un formato similar a \texttt{zip}.
El análisis se centraría en saber cómo extraer los ficheros para luego determinar qué datos tienen cada uno de ellos.
Como dato indicativo se tiene que los datos del primer fichero empiezan en la posición \texttt{0x54}, por lo que habrá que buscar un valor qué indique esta posición.
En la posición \texttt{0x0C}, se observa justo ese valor, seguido de \texttt{0x228}.
Frecuentemente, después de la posición de un fichero se indica su tamaño, por lo que habrá que comprobar si el primer fichero termina en la posición \verb!0x54 + 0x228 = 0x27C!. En la Figura~\ref{fig:met-bg2} se ve que en esa posición aparece la cabecera \texttt{RGCN}, estándar para otro formato de archivo.

\includefigure{fig:met-bg2}{Contenido de un fichero comprimido de \textit{Ninokuni}.}{imgs/MET-Bg2.png}

Esto corrobora la estructura que se intuía, por lo que por cada fichero hay 8 bytes indicando posición y tamaño.
Para determinar el número de ficheros se puede calcular cuantos archivos especifica esa \textit{tabla de contenidos}, restando el principio del primer fichero a la posición de la primera entrada y diviendo por el número de bytes dedicado a cada fichero: \verb!(0x54 - 0x0C) / 0x08 = 9!.
El resultado es que se han especificado 9 ficheros, valor que coincide con el encontrado en la posición \texttt{0x08} (Figura~\ref{fig:met-bg1}).

Esta forma de razonar es la que se ha empleado para averiguar de los formatos estudiados en el trabajo.
Faltaría averiguar el contenido de cada fichero.
Estudiando los formatos más comunes, se puede identificar (Figura~\ref{fig:met-bg2}) que al principio hay colores, pues cada valor de 16 bits está próximo al siguiente.
Al final hay información sobre cada píxel, índice al color de la paleta, pues se repiten muchos valores que están próximos, esto concuerda con el hecho de que un píxel en una imagen suele tener a su alrededor píxeles de similar color.

Otro ejemplo se encuentra en los archivos de tipo \texttt{PSAR} (Figura~\ref{fig:met-psar}) analizados en la Sección~\ref{sec:cr-nino}.
En ellos, en la posición \texttt{0x08}, mediante los caracteres \texttt{ASCII} se indica el tipo de compresión que se usa sobre los datos, \texttt{zlib}.

\begin{figure}[bh]
\centering
\includegraphics{imgs/CR-PSAR.png}
\caption{Primeros bytes del fichero \texttt{PSAR}.}
\label{fig:met-psar}
\end{figure}

\section{Depuración de código}
En ocasiones, no solo analizando un fichero con un visor hexadecimal se puede estudiar un formato.
Para codificaciones complejas y estudios de algoritmo como cifrados e integridad hace falta mirar en la implementación del juego.
En estos casos, mediante depuración del juego se pueden analizar las instrucciones máquina que ejecuta la consola, para saber cómo procesa el juego los ficheros y poder estudiarlos así.

Esto es posible gracias a los emuladores.
Para la \acl{NDS} existen principalmente dos formas de llevar a cabo este objetivo (Figura~\ref{fig:met-dep}).

\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=.4\linewidth]{imgs/MET-IDAPro.png}
    \caption{IDA Pro 6.1 con DeSmuME.}
\label{fig:met-idapro}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=.4\linewidth]{imgs/MET-Nosgba.png}
    \caption{Emulador con depurador integrado No\$GBA.}
\label{fig:met-nosgba}
\end{subfigure}
\caption{Programas para depurar juegos de \acl{NDS}.}
\label{fig:met-dep}
\end{figure}

El primero es usar el emulador de código abierto DeSmuME y el depurador IDA Pro.
Este emulador se puede compilar activando funciones de depuración remotas.
Incluye una implementación de \textit{GDB Remote Serial Protocol}\footnote{\url{http://www.embecosm.com/appnotes/ean4/embecosm-howto-rsp-server-ean4-issue-2.html}} que permite que programas externos, controlen la ejecución del juego paso a paso y accedan a la memoria \texttt{RAM}.
Esto es lo que hace IDA Pro, sirviendo como un depurador universal.
De esta forma se puede visualizar el código en ensamblador, poner puntos de interrupición y ver y cambiar la memoria del juego.

La alternativa es usar el emulador privativo No\$GBA.
Existe una versión que incluye un depurador, originalmente de pago, pero que recientemente se liberó como \textit{freeware}.
Incluye las mismas funciones descritas anteriormente, pero en este caso implementandas sobre el propio emulador, aumentando la eficiencia.

Dado que IDA Pro es un programa con una licencia básica de \$500, este trabajo se realizó con el emulador No\$GBA que a pesar de no tener tantas funcionalidad, sí provee de las necesarias para realizar el trabajo.
Además, se comenzó a implementar un depurador remoto, una versión de IDA Pro de código abierto, denominada NitroDebugger\footnote{\url{https://github.com/pleonex/nitrodebugger}}.
Aunque no llega es funcional todavía, la base de la aplicación está terminada.

\subsection{Búsqueda de archivos en RAM}
Esta subsección explicará el procedimiento seguido para, mediante depuración, averiguar cómo el juego procesa un fichero.
Para ello, hace falta conocer cómo el juego obtiene datos de la cartucho del juego.
El protocolo de comunicación es sencillo, cuando se necesitan datos se envía un comando, que el hardware cifra (esa parte, al usar un emulador, no se realiza), y al cual al cartucho responde con los datos solicitados.
El código de este comando es \texttt{0xB7} y se envía escribiéndolo en el puerto virtual \texttt{0x040001A8}~\cite{GbaTek}.

Conociendo la función de código que se encarga de envíar este comando, solicitando bloques de datos, y poniendo un punto de interrupción, de forma que la ejecución del juego se para pudiendo ver qué dirección se ha solicitado, se podría determinar qué archivo acaba de ser solicitado.
Dado que continuamente se están cargando datos, realizar esto manualmente no es viable, es por ello, que aprovechando que el emulador DeSmuME es de código abierto, se puede modificar para automatizarlo.

Esta mecánica se implementó para realizar los análisis de este trabajo con el programa \textit{NitroFilcher}\footnote{\url{https://github.com/pleonex/AiroRom/tree/master/Programs/NitroFilcher}}.
En el emulador se añadieron las siguientes líneas de código a la función \texttt{HandleDebugEvent\_Execute} del archivo \texttt{debug.cpp}, consiguiendo que cada vez que se ejecutara las instrucciones que solicitan datos, guardase en un fichero de texto la posición que se pedía junto al tamaño.

\begin{verbatim}
// 0x02016DE0 es la dirección de la función que solicita datos.
if (DebugEventData.addr == 0x02016DE0 && log_ptr != NULL) {
    u32 addr = DebugEventData.cpu()->R[2];
    u32 size = DebugEventData.cpu()->R[3];
    fprintf(log_ptr, "%08X,%08X,%08X\n", addr, size, addr + size);
}
\end{verbatim}

Este fichero luego lo procesaría el programa \textit{NitroFilcher}, escribiendo en otro fichero de texto las rutas a los archivos que correspondían esas direcciones.

\subsection{Búsqueda de algoritmos sobre textos}
\label{sec:met-search-text}
En el Capítulo~\ref{sec:translations} se mostrarán algoritmos para ofuscar y cifrar textos.
El procedimiento para realizar este estudio se basa en depuración de código.

El primer paso es buscar la frase en texto plano sobre el binario del juego.
Tras determinar que no aparece, se puede confirmar que puede estar codificada en una codificación no estándar, comprimida o cifrada.
Se suele probar con las codificaciones soportadas nativamente por las fuentes de \acl{NDS} como son \texttt{UTF-8}, \texttt{UTF-16}, \texttt{SHIFT-JIS} y \texttt{CP1252}.

Confirmado que hay un algoritmo que se aplica sobre el texto, el objetivo es encontrar este texto en la memoria \texttt{RAM} del juego, para poder poner un punto de interrupción y ver qué transformaciones se aplican hasta llegar al texto descifrado.
Para ello, se extrae la memoria, justo en el momento de mostrar ese diálogo, pues debería estar la frase guardad para poder mostrarla en pantalla.
Esto se puede realizar con cualquier emulador de \acl{NDS}.
Una vez extraído el archivo binario con la memoria, mediante visores hexadecimales se busca el texto usando de nuevo codificaciones estándar.
Si la frase se encuentra, se pondría un punto de interrupción en dicha posición y se estudiaría el algoritmo.
En caso contrario, probablemente se use una codificación propietaria, sin embargo se puede encontrar siguiendo la metodología explicada en los siguientes apartados.

\subsubsection{Búsqueda de la tipografía}
El primero consiste en buscar el archivo con la tipografía del juego, pues la codificación será la misma que el orden con el que aparecen los caracteres en ella.

El estandar de este formato tiene la cabecera \texttt{NTFR} y existen programas para extraer y editar este tipo de formatos\footnote{\url{https://github.com/pleonex/NerdFontTerminatoR}}.

\subsubsection{Búsqueda diferencial}
El segundo procedimiento posible es el de desarrollar un programa de búsqueda diferencial. Con motivo de este trabajo se explica el programa \textit{RelativeSearch} que se llevó a cabo. Este tipo de software se puede usar siempre y cuando el orden de los caracteres de un mismo grupo (por ejemplo letras minúsculas) corresponda a estándares como ASCII. Si se hubiese seguido un orden aleatorio en la codificación propietaria este no serviría quedando la primera opción como única alternativa.

\subsection{Búsqueda de algoritmo sobre imágenes}
\label{sec:met-search-img}
El procedimiento para encontrar el algoritmo de cifrado en este caso es distinto al realizado con texto.
No se puede partir de datos conocidos como anteriormente se hacía con una frase que se veía en la pantalla.
Sin embargo, dado que las cabeceras de la imagen suelen ser estandar, se puede buscar sobre el código en ensamblador la función que procesa esta cabecera.
En concreto se busca el identificador \texttt{CHAR}, que se procesa para determinar el comienzo de una sección del archivo.

Una vez encontrada la función que lee una imagen, se puede poner un punto de interrupción sobre ella, para tener acceso a los datos cifrados cuando el juego procese un archivo.
Una vez localizados, se ponde un punto de interrupción sobre ellos, este último, llevará al código que procesa estos datos, por tanto el algoritmo que los descifra.

\section{Intercepción de comunicación}
\label{sec:met-nds-desmume}
% explicar desmume modificado para guardar datos

% explicar rc4finder

% explicar sslpatcher

\section{Documentación}

% Explicar databrithm

% Comentar programas de los juegos

% explicar script de organización
