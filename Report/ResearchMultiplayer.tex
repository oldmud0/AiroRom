% Copyright (c) 2015 Benito Palacios Sánchez - All Rights Reserved.
% Esta obra está licenciada bajo la Licencia Creative Commons Atribución 4.0
% Internacional. Para ver una copia de esta licencia, visita
% http://creativecommons.org/licenses/by/4.0/.

\chapter{Servicios en línea}
\label{sec:multiplayer}
Este capítulo tiene el objetivo de analizar y mostrar los protocolos de comunicación de algunas plataformas y juegos, así como la seguridad aplicada sobre los ficheros transmitidos.
Este tipo de contenido se está volviendo más popular gracias a las tiendas virtuales, donde se venden pequeños extras.

En la sección multijugador se explicará cómo funciona la autenticación en los servidores de Nintendo y cómo puede afectar a la jugabilidad no usar HTTPS en el caso del juego Preguntados.
En la sección de contenido descargables se comentará la seguridad de tres juegos.
Por último, la sección de transmisión segura de código explica cómo se implementan mecanismos de integridad para la enviar juegos entre consolas.

\section{Multijugador}
\subsection{Conexión segura en servidores de Nintendo}
\label{sec:mp-nintendo-server}
El 20 de mayo de 2014 Nintendo cesó su servicio de conectividad Wi-Fi para las consolas \acl{NDS} y Wii~\cite{Nintendo-Cese}.
Los juegos en línea, torneos, contenido descargable e intercambio de objetos se deshabilitaron con el cierre de estos servidores~\cite{Nintendo-Cese2}.
Por ello, un grupo de usuarios investigó el protocolo de comunicación entre la consola y el servidor, creando una aplicación web que replicase el funcionamiento\footnote{\url{https://github.com/polaris-/dwc_network_server_emulator}}.
En este apartado se estudiará el protocolo.

La sección~\ref{sec:met-nds-desmume} del capítulo de metodologías explica cómo modificar el emulador DeSmuME de \acl{NDS} para capturar tráfico.
Tras conseguir una captura (figura~\ref{fig:mp-nintendo-encry}), se pudo ver que, a parte de una primera comunicación \texttt{HTTP}, el resto se cifra mediante \texttt{HTTPS}.
Para poder eludir la capa de seguridad de \texttt{TLS}, se descubrieron dos mecanismos: capturar la función de cifrado y forzar el uso de \texttt{HTTP}.

\includefigure{fig:mp-nintendo-encry}{Primeros paquetes de una comunicación entre una \acl{NDS} y los servidores de Nintendo.}{imgs/MP-NintendoEncry.png}

El primero consiste en encontrar la función que cifra la comunicación, el algoritmo \texttt{RC4}, en el juego.
Dado que este código se incluye con la biblioteca que proporciona Nintendo a los desarrolladores, será igual en todos los juegos.
Esta táctica es la que implementa el programa \textit{RC4Finder}\footnote{\url{https://github.com/pleonex/AiroRom/tree/master/Programs/RC4Finder}} para encontrar y devolver la posición de la función.

Conociendo dónde se encuentra el algoritmo de cifrado y aprovechando las capacidades de depuración del emulador, se puede implementar una funcionalidad para que guarde en un fichero los datos que pasan por el algoritmo.
Dado que el mismo algoritmo se usa para cifrado y descifrado (es un cifrado simétrico), hará falta controlar dos puntos de la función.
Si se quiere obtener los datos que envía el juego, serán aquellos que se van a cifrar y que po tanto, será el contenido inicial al principio de la función.
En el caso de querer guardar los datos que se reciben, los que se descifrarían, que estarán al final del algoritmo.
El mecanismo se ha implementado usando el método \verb!HandleDebugEvent_Execute! del archivo \texttt{debug.cpp} que se llama después procesar cada instrucción.
En el repositorio del proyecto se encuentra el archivo con la implementación\footnote{\url{https://github.com/pleonex/AiroRom/blob/master/Programs/DeSmuME PCAP/debug.cpp}}.
Hay que tener en cuenta que necesita ser modificada para cada juego para poner el inicio y el final del algoritmo \texttt{RC4}.

El segundo mecanismo se debe a un fallo de seguridad por parte de Nintendo.
Los servidores están mal configurados y, \textbf{admiten tanto peticiones \texttt{HTTPS} como \texttt{HTTP}} ofreciendo la misma funcionalidad.
Además, con solo cambiar la parte de protocolo de la \texttt{URL} en el código del juego, se adapta automáticamente y deja de cifrar la comunicación.
El procedimiento de editar todas las direcciones para usar una conexión sin cifrar se ha implementado en el programa \textit{SslPatcher} incluido en el repositorio del trabajo\footnote{\url{https://github.com/pleonex/AiroRom/tree/master/Programs/SslPatcher}}.
Solo los servidores de contenido descargable denegaban conexiones al puerto 80 (el usado en \texttt{HTTP}).

Una vez capturados los paquetes sin cifrar (figura~\ref{fig:mp-nintendowifi}), se pudo analizar la comunicación entre un total de tres servidores.
En el diagrama~\ref{fig:mp-nintendo-comm} se describen los mensajes con los
parámetros más importantes.

\includefigure{fig:mp-nintendo-comm}{Comunicación entre \acl{NDS} y servidor de Nintendo para descargar un fichero.}{diagrams/nds_dwc.eps}

\begin{enumerate}
    \item Prueba de conexión.
    Se realiza una prueba de conectividad con una petición \texttt{HTTP} a la dirección \texttt{conntest.nintendowifi.net}.
    Este devuelve una página \texttt{HTML} con el texto \textit{This is a test.html page}.

    \item Autenticación en servidor \ac{NAS}.
    Primera conexión de autenticación con el servidor \ac{NAS}.
    El juego se autentica mediante el comando \texttt{login}, pasando como parámetros un identificador del juego (\texttt{gamecd}) y una clave (\texttt{passwd}).
    Adicionalmente, la consola también envía un ID de usuario, el ID del desarrollador del juego, el BSSID del punto de acceso, la dirección MAC de la consola, el lenguaje configurado, la fecha de cumpleaños del usuario y el nombre del usuario.
    El servidor contesta enviando un \textit{token} generado y un \textit{challenge} que se explicarán más tarde.

    \item Localización de servidor externo.
    Esta conexión se realiza cuando se pide contactar con un servidor externo como de contenidos descargables (comando \texttt{svcloc}).
    Se descarta los datos de la operación anterior (\textit{token} y \textit{challenge}) y se devuelve uno nuevo para ese servicio en concreto (\texttt{servicetoken}) junto con la dirección a la que contactar (\texttt{svchost}).

    \item Contacto con el servidor de contenidos.
    En primer lugar el juego envía siempre el comando \texttt{count} donde opcionalmente puede especificar un filtro.
    El servidor devolvería el número de ficheros que coinciden con dicho filtro, como en este caso no se ha especificado ninguno, devuelve el valor cero.
    Para autenticarse en este servidor usa tanto el \texttt{servicetoken} que devolvió el \ac{NAS} como el código del juego y una contraseña que es diferente a la usada en el servidor anterior.

    \item Obtención del nombre de los ficheros.
    El juego envía el comando \texttt{list} para obtener la lista de ficheros disponibles.
    Para realizar un filtro sobre esa lista, utiliza los campos \texttt{offset} (índice de la lista por el que comenzar) y \texttt{num} (número de elementos a devolver).
    El servidor envía en cada línea el nombre del fichero y su tamaño.

    \item Finalmente el juego pide un fichero mediante el comando \texttt{content}.
\end{enumerate}

\includefigure{fig:mp-nintendowifi}{Petición respuesta descifrada entre \acl{NDS} y servidor de Nintendo.}{imgs/MP-NintendoWifi.png}

Este protocolo tiene ciertos \textbf{fallos tanto de seguridad como de eficiencia}.

\begin{itemize}
    \item En el caso de querer contactar con el servidor de descargas (caso descrito anteriormente), la primera comunicación con el \ac{NAS} es innecesaria.

    \item La contraseña enviada al servidor \ac{NAS} no se verifica si coincide con el código de juego, pudiendo especificar la de otro y dejarla constante.
    Sin embargo, la que se usa en el servidor de descargas sí se comprueba.

    \item La autenticación con el servidor de contenidos es de tipo \ac{PAP} (solo se utiliza una contraseña), frente la del servidor de juegos en línea que es \ac{CHAP} (autenticación mediante \textit{tokens}).

    \item Conociendo la contraseña de un juego y gracias al comando \texttt{list}, se puede crear un programa que solicite todos los ficheros del servidor y los descargue.
    Esto se hizo a la hora de recuperar los contenidos descargables cuando se conoció que los servidores de Nintendo iba se iban a desactivar.
\end{itemize}

Respecto a la comunicación \texttt{HTTPS}, la implementación sobre la consola es segura y no se pueden usar servidores alternativos sin modificar el juego.
Dentro de este se encuentran los certificados que los servidores de Nintendo utilizan durante el intercambio de claves del protocolo \texttt{HTTPS}.
El juego comprueba que el certificado no haya expirado, no tenga problemas de formato, que la firma sea válida y que coincida con uno de los de su lista.
Sin embargo, comprueba el campo del nombre del servidor.
Por defecto, los juegos incluyen un certificado a nombre de Nintendo, dos de VeriSign, tres de CyberTrust, dos de Thawte y dos de GlobalSign.

Para finalizar, se investigó el algoritmo usado para generar un \textit{token} de autenticación en los juegos en línea (figura~\ref{fig:mp-nintendotoken}).
En ese caso, después de la primera conexión con el \ac{NAS}, se inicia una comunicación con el servidor multijugador cuyo protocolo está basado en \textit{GameSpy}.
Para contactar, es necesario que los \textit{tokens} generados por la consola y servidor coincidan.
Iniciada la conexión \texttt{TCP}, este le enviará un primer mensaje con un segundo \textit{challenge}.
El \textit{token} a calcular es el resultado de aplicar el algoritmo \texttt{MD5} sobre la cadena de caracteres formada al concatenar los siguientes parámetros (conocidos por ambas entidades).
\begin{itemize}
    \item \texttt{MD5} del \textit{challenge} del servidor \ac{NAS}.
    \item 48 espacios en blanco
    \item \textit{Token} del servidor \ac{NAS}
    \item \textit{Challenge} generado por la consola que se transmitirá junto a este mensaje.
    \item \textit{Challenge} enviado por este servidor.
    \item \texttt{MD5} del \textit{challenge} del servidor \ac{NAS}.
\end{itemize}

\includefigure{fig:mp-nintendotoken}{Mensajes descifrados entre los servidores multijugador para \ac{NDS}. En verde el \textit{token} generado.}{imgs/MP-NintendoToken.png}

De esta forma solo aquellos dispositivos que reunan tanto los códigos devueltos por el servidor que da acceso a la red como el algoritmo para calcularlo serán capaces de comunicarse con éxito.
Esta parte fue clave a la hora de realizar un servidor alternativo.

Dado que no se conocen las claves privadas de Nintendo, no se puede realizar una conexión segura con el juego y el servidor alternativo.
Para solventar el problema sin tener que modificar los certificados existentes se usa un servidor \textit{proxy} de \texttt{DNS} como se explica en el diagrama de la figura~\ref{fig:mp-nintendodns}.
Este servidor DNS resuelve los dominios de Nintendo apuntando a los alternativos.

\includefigure{fig:mp-nintendodns}{Conexión a los servidores alternativos de Nintendo.}{imgs/MP-NintendoDNS.eps}

\subsection{Preguntados}
\label{sec:mp-mp-preg}
% Introducir juego -> escenario man-in-the-middle -> mostrar trazas wireshark
\textit{Preguntados} es un juego desarrollado por \textit{Etermax} en el año \textit{2013} para las plataformas iOS, Android y Windows Phone.
La aplicación encuentra adversarios de forma aleatoria y muestra una serie de preguntas con posibles opciones.

El objeto de este estudio es comprobar si la seguridad en las comunicaciones es segura, evitando posibles trampas.
Para ello se preparó un escenario para realizar un ataque \textit{man-in-the-middle}.
Un punto de acceso adicional se conectó al ordenador mediante \textit{Ethernet} y este a su vez mediante conexión Wi-Fi con el punto de acceso original.
Dado que el sistema operativo \textit{Fedora 20} por defecto tiene una configuración restrictiva de red, hubo que diseñar el siguiente \textit{script} para compartir la conexión.

\begin{verbatim}
# El primer argumento es la IP de la interfaz que tiene conexión a Internet
# Crea la ruta hacia la subred
sudo route add -net 192.168.3.0/24 gw 10.42.0.29 p35p1

# Habilita SNAT para la segunda subred
sudo iptables -t nat -I POSTROUTING -s 192.168.3.0/24 -o wlp4s0 -j SNAT --to $1

# Permite los paquetes de destino la segunda subred
sudo iptables -t filter -I FORWARD -d 192.168.3.0/24 -j ACCEPT

# Permite los paquetes con origen la segunda subred
sudo iptables -t filter -I FORWARD -s 192.168.3.0/24 -j ACCEPT

# Permite sin restricción los paquetes con destino la primera subred
sudo iptables -t filter -I FORWARD -d 10.42.0.0/24 -j ACCEPT
\end{verbatim}

Los paquetes capturados con \textit{Wireshark} muestran que no se usa una conexión segura ya que se transmite todo por \texttt{HTTP}.
Como se ve en la figura~\ref{fig:mp-preguntados}, tras analizar la transmisión de datos con el servidor del juego se encuentra una mala implementación del protocolo.
Cada vez que una partida comienza, el servidor le envía al usuario una lista de preguntas y respuestas a usar \textbf{junto a la respuesta correcta}.
Dado que la comunicación no está protegida, y se puede capturar, es posible saber la respuesta a cualquier pregunta antes de que se realice.
A parte de los problemas de seguridad y confidencialidad que esto implica, esto permitiría crear un programa que responda automática a las preguntas.

\includefigure{fig:mp-preguntados}{Captura de tráfico con las preguntas y respuestas de una partida de Preguntados.}{imgs/MP-Preguntados.png}

Una buena implementación hubiese sido que el servidor enviase solo las preguntas con sus posibles respuestas, y que la respuesta escogida se envíe al servidor donde se comprobaría, además de usar \texttt{HTTPS}.

\section{Contenido descargable}
\subsection{100 Classic Books Collection}
\label{sec:mp-dlc-books}
\textit{100 Classic Books Collection} se trata de un juego que como se analizó en la sección~\ref{sec:cr-100-books} ofrece al usuario un lector de libros electrónicos.
Este juego provee además de una opción de comunicación inalámbrica para descargar alrededor de 20 nuevos libros.
Estos se almacenarían en el archivo de guardado del usuario.
Tras analizar las comunicaciones usando la versión modificada de \textit{DeSmuME}, se pudo observar que estos ficheros descargados no estaban cifrados, teniendo el mismo formato que aquellos que se encuentran dentro del juego. % TODO: Verificar

Reproducir contenido desde un archivo de guardado, teniendo en cuenta que se añade mediante descarga externa, es una vulnerabilidad a explotar para ejecutar código no autorizado.
Se podría encontrar un fallo de seguridad como un desbordamiento de buffer al insertar un texto muy largo, y obtener el control de la consola.
Esta es la técnica que se utiliza para ejecutar copias de seguridad de juegos en \acl{DSi}.

\subsection{Ninokuni: El Mago de las Tinieblas}
\label{sec:mp-dlc-nino}
% Decir que archivos se bajan -> desmume -> cifrado RC4 -> integridad
\textit{Ninokuni} es un juego que como se comentó en la sección~\ref{sec:tr-nino} es para la \textit{Nintendo DS}.
\textit{Level-5} ofrecía dos servicios adicionales para el juego mediante la conectividad inalámbrica.
El primero se trataba de una lista de noticias cortas relacionadas con la historia que salían una vez al día y, la segunda era contenido adicional como objetos o misiones.
Ambas se obtenían descargando unos archivos de los servidores de Nintendo con el protocolo descrito en el apartado~\ref{sec:mp-nintendo-server}.

Usando la versión modificada de DeSmuME se pudo obtener los paquetes descifrados, pero no se encontró texto dentro de los binarios que se descargaban.
Tras investigar las instrucciones máquinas que procesaban el fichero se vio que se usaba el algoritmo \texttt{RC4} para descifrar los archivos.
Por tanto, en una comunicación normal, este algoritmo se usaba dos veces, una para la capa de sesión \texttt{TLS} y otro en la capa de aplicación.
Las claves en esos dos casos son diferentes, pues en la última es una constante almacenada en el juego mientras en la primera se crea para cada conexión.

A parte del cifrado, se encontró un algoritmo de integridad en la posición \texttt{0x04} de ambos ficheros.
Concretamente se aplica el algoritmo \texttt{CRC32} que, aunque no son necesarios porque se usa \texttt{TCP}, asegura que el juego no procese datos no esperados.

\subsection{Duet}
\label{sec:mp-dlc-duet}
Por último se verá el caso del juego \textit{Duet} para \textit{iOS} y sus niveles extras.
Se trata de una compra integrada en la aplicación por 0.99 euros que añade un nuevo conjunto de pruebas.
Analizando de nuevo el contenido de la carpeta centrándose en estos niveles, se averigua que estos presentes y que mediante la compra se activan.
La búsqueda se centra en saber dónde se guarda la configuración del juego para ver si está protegida o si se podría evitar la compra y activar manualmente.

\includefigure{fig:mp-duet}%
{Filas de la base de datos de \textit{Duet} que activan el contenido extra.}%
{imgs/MP-Duet.png}

En la carpeta \textit{Documents} de la aplicación existen tres bases de datos \textit{sqlite}.
Abriendo la de mayor tamaño, \textit{persistent-data.db} nos encontramos las filas de la figura~\ref{fig:mp-duet}.
En ella se ve como los valores que activan el contenido extra, el contenido de pago, están puestos a \texttt{0}, el valor que corresponde a \textit{desactivado}.
Si se cambia a \texttt{1} y se inicia la aplicación de nuevo nos encontraremos con este contenido activado.

La protección ante este tipo de casos es tan sencilla como poner una contraseña a la base de datos.
Se trata de un mecanismo que está implementado nativamente\footnote{\url{http://stackoverflow.com/a/24349415/3021815}} en las bibliotecas de \textit{sqlite} y muy sencillo de usar.
La contraseña se puede almacenar en texto plano en la aplicación, pues dificultará la tarea de conocerla y al valer el contenido tan poco (menos de 1 euro) no compensará el esfuerzo dedicado como se ha discutido en capítulos anteriores.

\section{Transmisión segura de código}
\label{sec:mp-sign}
% Introducir DWP -> seguridad para ejecutar codigo no autoridazo -> paquete integridad de arm9 -> este integridad de datos -> no se puede man-in-the-middle -> se puede editar de flashcard.
Una de las posibilidades de comunicación inalámbrica que ofrece la \ac{NDS} es que un juego envíe una \textit{demo} a otra consola, en algunos casos incluso para poder jugar en multijugador teniendo un único juego, denominado \textit{Download Play}.

En este contexto, dado que la transmisión de código se hace en un canal compartido (se usa el protocolo \textit{Wi-Fi}), son necesarios mecanismos que protegen la comunicación.
De esta forma no sería posible realizar un ataque \textit{man-in-the-midle} para ejecutar código no autorizado introduciendo así una brecha de seguridad.

El protocolo~\cite{GbaTek-MultiBoot} implementa varios mensaje, los más importantes en cuanto seguridad son \texttt{RSA signature} y \texttt{data}.
Con el primero se envían los archivos binarios de código principales de la aplicación, uno por procesador.
Este mensaje está además firmado usando \texttt{SHA-1} para que no se pueda alterar el código.
El segundo mensaje sirve para transmitir el resto de datos del juego como imágenes, textos y sonidos.
Sin embargo, en algunos casos, dado que el fichero principal de código es muy grande, este se divide en partes llamados \textit{overlays}.
Estos archivos se tratan como ficheros normales y son transmitidos en el segundo paquete, que no está firmado.

Para solventar este problema, Nintendo introdujo una comprobación de seguridad que a diferencia de la que se aplica sobre el archivo principal, esta se realizar durante la ejecución del juego.
A cada archivo de código secundario se le realiza un algoritmo de tipo \texttt{HMAC} (\texttt{SHA-1} para el \textit{hash}), con una clave que se guarda en el archivo de código principal.
Este resultado se comprueba con uno almacenado y en caso de fallar se para la ejecución del juego.

Este procedimiento, aunque implementado en la mayoría de juegos, solo se activa si se está ejecutando con el modo de \textit{Download Play}.
En este modo, se activa un bit del \textit{firmware} (posición en la memoria RAM \texttt{0x27FFC40}), y durante la ejecución se comprueba para saber si hay que verificar los archivos.
En otro caso, como el de un inicio normal desde el cartucho, se asume que no es necesario pues no han tenido modificación externas.

Ese valor está desactivado en emuladores como DeSmuME y \textit{flashcards} para poder aplicar parches antipiratería y saltarse el mecanismo.
De esta forma, una vez modificado el juego original, se puede enviar a otras consolas el juego editado, permitiendo ejecutar código no seguro.
