% Copyright (c) 2015 Benito Palacios Sánchez - All Rights Reserved.
% Esta obra está licenciada bajo la Licencia Creative Commons Atribución 4.0
% Internacional. Para ver una copia de esta licencia, visita
% http://creativecommons.org/licenses/by/4.0/.

\chapter{Traducciones no oficiales y mods}
\label{sec:translations}

% TODO: Introducción de traducciones no oficiales y mods

\section{Saga Pokémon en \acl{NDS}}

% TODO: Introducción de Pokémon

Los textos que aparecen en diálogos y menús, al igual que aquellos nombres para denominar a \textit{Pokémons} y ataques son el primer objetivo a la hora de realizar una traducción.

\subsection{Pokémon Perla y Diamante}
El par de juegos \textit{Pokémon Diamante y Perla} corresponden a la cuarta generación de saga y a la primera que salió para \acl{NDS}.
El primer país en recibirlos fue Japón a finales de septiembre de 2006 y como es frecuente mucho después llegó al resto del mundo.
Concretamente pasaron siete meses hasta la llegada a Estados Unidos y tres meses más hasta la llegada a Europa.

\subsubsection{Archivos}
Se trata del primera generación de juegos que llegan a esta consola donde como característica importante respecto a su antecesora (\acl{GBA}) es la introducción del sistema de ficheros.
En estos tres juegos, los archivos dentro del juego tienen nombres explicativos sobre su contenido (figura~\ref{fig:tr-pearlfiles}).
Ejemplo son ficheros como \textit{msgdata/msg.narc} con los mensajes o textos del juego, \textit{itemtool/itemdata/item\_icon.narc} con las imágenes de los objetos o \textit{graphic/font.narc} con las tipografías del juego.

\includefigure{fig:tr-pearlfiles}%
{Sistema de ficheros en Pokémon Perla visto con Tinke}%
{imgs/TR-PearlFiles.png}

\subsubsection{Textos}
\label{sec:tr-pok-pearl-text}
Centrándose en textos del juego se comprueba que están cifrados.
Tras una búsqueda de las frases de diálogos iniciales sobre todo el archivo binario del juego no se encuentran resultados.
Se probó en las codificaciones más frecuentes de esta consola como son ASCII y UNICODE sin resultado.
Esto indica que bien el archivo que contiene los textos está comprimido o cifrado.

El siguiente procedimiento fue extraer la memoria RAM del juego justo en el momento de mostrar ese diálogo, pues debería estar almacenada esa frase para poder ser mostrada en pantalla.
Esto se puede realizar gracias al emulador DeSmuME mencionado en el capítulo~\ref{sec:requirements}.
Una vez extraído el archivo binario con la memoria RAM, mediante visores hexadecimales se buscó la frase que aparecía en pantalla usando las codificaciones estándar y sin obtener resultado de nuevo.
Dado que la frase ha de estar en la memoria RAM, el problema era por tanto que no estaba usando una codificación estándar.
Existen dos procedimientos básicos para realizar una búsqueda en estos casos.

El primero consiste en buscar el archivo con la tipografía del juego, pues la codificación será la misma que el orden con el que aparecen los caracteres en ella.
En la tabla~\ref{tab:tr-pearlfont} se especifica el formato usado en este juego para estos archivos.
% TODO: Crear plugin de Tinke para exportarla.
% TODO: Añadir imagen de la tipografía extraída.

\ctable[
    caption = Especificación de tipografías en Pokémon Perla,
    label   = tab:tr-pearlfont,
    pos     = h
]{ccl}{
    \tnote[a]{Los caracteres están codificados por \textit{tiles} de 8x8 píxeles en formato horizontal.}
    \tnote[b]{Cada byte indica el ancho del caracter.}
}{                                                                      \FL
    Posición      & Tamaño        & Descripción                         \ML
    \multicolumn{3}{c}{Cabecera}                                        \NN
    \textsf{0x00} & \textsf{0x04} & Puntero a la sección de datos       \NN
    \textsf{0x04} & \textsf{0x04} & Puntero a la sección \acs{VWT}      \NN
    \textsf{0x08} & \textsf{0x04} & Número de caracteres                \NN
    \textsf{0x0C} & \textsf{0x01} & Ancho de un caracter                \NN
    \textsf{0x0D} & \textsf{0x01} & Alto de un caracter                 \NN
    \textsf{0x0E} & \textsf{0x01} & BPP                                 \NN
    \textsf{0x0F} & \textsf{0x01} & BPP                                 \ML
    \multicolumn{3}{c}{Datos de la fuente\tmark[a]}                     \ML
    \multicolumn{3}{c}{\ac{VWT}\tmark[b]}                               \LL
}

El segundo procedimiento posible es el de desarrollar un programa de búsqueda diferencial.
Con motivo de este trabajo en el capítulo~\ref{sec:requirements} se explica el programa \textit{RelativeSearch} que se llevó a cabo.
Este tipo de \textit{software} se puede usar siempre y cuando el orden de los caracteres de un mismo grupo (por ejemplo letras minúsculas) corresponda a estándares como ASCII.
Si se hubiese seguido un orden aleatorio en la codificación propietaria este no serviría quedando la primera opción como única alternativa.

Tras usar cualquiera de los dos procedimientos anteriormente descritos, se puedo encontrar una coincidencia en la memoria RAM del diálogo.
El siguiente paso consistió en depurar el juego para hallar el algoritmo de descifrado o descomprensión de textos.
Para ello usando los programas descritos en el capítulo~\ref{sec:requirements} de depuración, se puso un punto de interrupción en dicha posición.

Cabe destacar que esta posición es dinámica por lo que cambia cada vez que se inicia el juego pues depende de muchas variables.
Para sortear este problema se hizo uso de los \textit{savestates} del emulador, es decir guardados de memoria del juego que permiten ir a cualquier momento de una ejecución.
Gracias a esta característica se puede realizar un guardado justo antes de que el juego guarde un juego de forma que siempre que se use ese \textit{savestate} encontraremos el texto en la misma posición.
El punto de interrupción hizo parar el emulador justo en las instrucciones máquinas que estaban realizando, en este caso, el descifrado. Este algoritmo se describe a continuación.

El texto se encuentra cifrado usando la operación XOR y mediante una clave que se actualiza después de descifrar cada byte\footnote{Al no ser una clave constante no se puede obtener esta al ser aplicada sobre zonas con valores a 0 como sí sucede en el caso de la tabla de contenido.}.
La clave inicial es igual a \verb!clave = (ushort)(0x91BD3 * (i + 1))! donde \verb!i! es el bloque de texto a descifrar.
Después de aplicar la clave sobre un byte esta se actualiza según \verb!clave = (ushort)(clave + 0x493D)!.

El cifrado no es exclusivo del texto pues la tabla de contenido con las posiciones y tamaños de cada diálogo se encuentra cifrado también.
La clave no coincide con la del texto y se forma de la siguiente manera: \verb!clave = (ushort)(clave_base * 0x2FD * (i + 1))!.
En este caso, se hace uso de una clave base que se encuentra disponible en la cabecera del fichero y de nuevo con número de entrada a descifrar (\verb!i!).
Dado que el tamaño de estos campos cifrados es de 32 bits y la clave de 16 bits, se concatena la clave dos veces formando el valor de 32 bits necesario para aplicar la operación XOR.

Sin embargo, esta parte del fichero a pesar de estar cifrado presenta un fallo de seguridad.
Como se ha comentado los valores cifrados de posición y tamaño son de 32 bits (4 bytes) pero en la mayoría de los casos solo se usan los dos primeros bytes pues tamaño del fichero de texto no supera los \verb!2^16 = 65535 bytes!.
Debido a la concateniación de la clave y a que los dos últimos bytes son 0, al cifrar estos dos bytes se estuvo guardando la clave en texto plano.
Es decir, se demuestra que \verb!a XOR 0 = a! siendo en este caso \verb!a! la clave para cifrar estas entradas y el valor guardado en el fichero en la mayoría de los casos.

En la tabla~\ref{tab:tr-pearltxt} se especifica el formato de los archivos de texto.

\ctable[
    mincapwidth = 110 mm,
    footerwidth,
    caption = Especificación del formato de texto en Pokémon Perla,
    label   = tab:tr-pearltxt,
    pos     = h,
]{ccl}{
    \tnote[a]{Se especifica solo la primera entrada.}
    \tnote[b]{Campo cifrado descrito en la sección~\ref{sec:tr-pok-pearl-text}.}
}{                                                                      \FL
    Posición      & Tamaño        & Descripción                         \ML
    \multicolumn{3}{c}{Cabecera}                                        \NN
    \textsf{0x00} & \textsf{0x02} & Número de bloques de texto          \NN
    \textsf{0x02} & \textsf{0x02} & Clave base para descifrar \acs{TOC} \ML
    \multicolumn{3}{c}{\acl{TOC}\tmark[a]}                              \NN
    \textsf{0x00} & \textsf{0x04} & Posición del texto\tmark[b]         \NN
    \textsf{0x04} & \textsf{0x08} & Tamaño del texto\tmark[b]           \ML
    \multicolumn{3}{c}{Texto\tmark[b]}                                  \LL
}

\subsubsection{Imágenes}
En el caso de la saga de Pokémon las imágenes no contienen frases con texto por lo que en cuanto a una traducción respecta no son necesarias editarlas.
Sin embargo, dada la popularidad de los \textit{mods} y de la extracción de imágenes en estos juegos se apostó por cifrar un tipo concreto de las mismas.
Se trata de los \textit{sprites} de los \textit{Pokémons} que aparecen durante las batallas.
Estos archivos están contenidos en el paquete \textit{poketool/pokegra/pokegra.narc} donde hay seis imágenes por monstruo.

El cifrado se realizó sobre los datos de la imagen, manteniendo las cabeceras del formato de la misma sin cifrar.
Como consecuencia, las imágenes se podían abrir usando programas estándares pero sin ver nada en concreto.
% TODO: Hacer programa y descifrar una imagen y poner comparativa

El procedimiento para encontrar el algoritmo de cifrado en este caso es distinto al realizado con texto.
No se puede partir de datos conocidos como anteriormente se partía de una frase que se veía en la pantalla.
Sin embargo, dado que las cabeceras de la imagen no están cifradas se pudo buscar sobre el código en ensamblador la función que procesa esta cabecera.
En concreto se buscó la palabra mágica \textsf{CHAR} que se procesaa para determinar el comienzo de una sección del archivo.

Una vez encontrado la función que lee una imagen, solo habría que acceder a una parte del juego donde se esperaba que se cargase una imagen como durante una batalla y poner un punto de interrupción sobre esta función.
Tras omitir imágenes que no estaban cifradas\footnote{Dado que una imagen contiene suele tener píxeles cercanos de igual colores, siempre que en los datos se observara patrones se podía determinar que no estaba cifrada.}, se llegó a una que sí lo estaba donde se puso un punto de interrupción.

La siguiente función que leía los datos de dicha imagen era el algoritmo de descifrado. Este algoritmo parte del hecho que todo el bloque de datos de una imagen tendrá el tamaño constante de \textsf{0x1900} bytes.
Se trata de un cifrado parecido al realizado sobre el texto donde habrá una clave que irá cambiando después de aplicarse sobre cada valor y que se usará para aplicar la operación XOR sobre un dato cifrado.
En este caso, la clave es de 32 bits y el dato a descifrar de 16 bits y se comencerá desde el final del fichero hasta el principio.
La clave inicial será el primer valor (últimos dos bytes del fichero) e irá cambiando siguiendo la siguiente operación \verb!clave = (uint)(clave * 0x41C64E6D + 0x6073)!.
