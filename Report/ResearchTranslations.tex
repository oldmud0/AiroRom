% Copyright (c) 2015 Benito Palacios Sánchez - All Rights Reserved.
% Esta obra está licenciada bajo la Licencia Creative Commons Atribución 4.0
% Internacional. Para ver una copia de esta licencia, visita
% http://creativecommons.org/licenses/by/4.0/.

\chapter{Traducciones no oficiales}
\label{sec:translations}
La primera sección de este trabajo abarcará el caso de las traducciones no oficiales, también conocidas como \textit{fan-traducciones}~\cite{Wiki-Trans}. Se trata de localizaciones a un idioma determinado realizadas de forma altruista por usuarios que quieren ver y compartir un juego determinado en su idioma. Existen numerosos casos como los tratados en la siguientes secciones con la saga \textit{Pokémon} y la versión para \acl{NDS} de \textit{Ninokuni}.

A pesar de no ser totalmente legal realizar este tipo de trabajos, desde el inicio de las videoconsolas cuando este movimiento comenzó hasta el año pasado no hubo ningún tipo de reclamación o pronunciamiento por parte de las compañías. Esto se debe a que estos juegos traducidos no iban a salir al mercado seguramente por motivos económicos por lo que una traducción solo haría conocer a ese juego y compañía en más lugares. La excepción más notable a este caso se produce en los juegos de \textit{Pokémon} que como se comentará más adelante, a pesar de que desde su lanzamiento en Japón el juego suele tener una fecha confirmada de salida en el resto de paises, muchas páginas y comunidades, a veces de forma altruista y otra para ganar visitas, deciden traducir parcialmente el juego antes de que llegue oficialmente. Aislando este hecho que solo se conoce en esta saga, existen muchos casos donde cuando se confirma una fecha oficial por respeto a la compañía se para la traducción como se verá en la última sección de este capítulo.

Recienmente este año se ha dado el caso de la compaía \textit{Square Enix} que por `motivos de mercado' enviaron cartas de \textit{cese y desista} sobre dos traducciones no oficiales: \textit{Final Fantasy Type-0}~\cite{VG247-FF0} para \acl{PSP} y \textit{Dragon Quest VII}~\cite{Reddit-DQ7} para \acl{N3DS}. En ambos casos, los grupos de traducción en cuanto lo recibieron pararon la traducción. Los motivos principales es que esta empresa en el primer caso ya había confirmado la salida del juego pero para otra consola (\acl{PS4}) y en el segundo seguramente por una confirmación que se hará recientemente. Cabe destacar que ambos grupos pararon su actividad al recibir la noticia, aunque el primero continuó una vez salida la traducción oficial ya que estaban trabajando sobre otra plataforma.

Relacionado con las traducciones se encuentran los \textit{mods}~\cite{Wiki-Mods}, es decir modificaciones sobre un videojuego con el objetivo de crear uno totalmente diferente. Usando el motor del juego actual, los usuarios modifican los archivos cambiando la historia, las imágenes, sonidos y \textit{scripts} para crear versiones alternativas. Existen comunidades dedicadas exclusivamente a este motivo como es \textit{Whack a Hack!}\footnote{\url{http://wahackpokemon.com/es}} para la saga \textit{Pokémon}.

Para dar a conocer qué mecanismos implementan algunas compañías para evitar tanto las modificaciones de juegos como traducciones anticipadas, se van a analizar una serie de videojuegos donde se mostrará qué tipo de protección sobre los ficheros se ha implementado. Estos mecanismos, en su mayoría de cifrado y ofuscación no evitan que esto se produzca pues dado que se tiene acceso al código máquina siempre se puede mirar como el juego accede a los ficheros, sin embargo sí pueden retrasar y en muchos casos imposibilitar a la mayoría de usuarios que no tienen los conocimientos necesarios para llevarlo a cabo. Este problema no es muy conocido en las desarrolladores de videojuegos pues pocos los implementan y siempre que tengan confirmada una salida en otro idioma podrían implementarlos para evitar tener pérdidas económicas.

\section{Saga Pokémon en \acl{NDS}}
\textit{Pokémon} es una serie de juegos desarrollados por la compañía \textit{Game Freak} desde el año 1993 para las consolas de Nintendo.
Esta saga de juegos se divide en las denominadas `generaciones' que engloban por lo general al menos tres juegos. Sus características es un mismo mapa, con una historia casi idéntica y un conjunto de \textit{Pokémon} común para conseguir.
Esta ha sido una de las franquicias más exitosas a nivel mundial y cuenta con una serie de animación, películas y miles de seguidores.

A causa de su fama, existe siempre un gran número de usuarios que no pueden esperar a que salga en su país para poder jugarlo.
Este es el problema que se deriva de que los juegos se suelan lanzar primero en Japón, entorno seis meses más tarde en América y pocos meses después en Europa.
Los usuarios ven que su única posibilidad de jugar al juego, a pesar de contar con fechas de localización confirmadas y exactas, en obtener una copia ilegítima del juego en un idioma que en la mayoría de los casos desconocen (japonés).

Aprovechando esta demanda, en esos meses de intervalos entre fechas de lanzamiento en diversos países surgen páginas webs cuyo objetivo es promocionarse y ganar usuarios lanzando una traducción no-oficial y parcial del juego.
Este es el caso de páginas que se promocionan con (traducido del inglés\footnote{\url{http://pokecheats.net/tools/translations.php}})
\textquote{PokéCheats.net está comenzando a posicionarse en traducciones anticipadas de juegos de Pokémon de Nintendo que están saliendo este año. Nuestro objetivo es el de darte una traducción de los juegos japoneses en tu idioma, para que puedas comenzar a jugar los próximos títulos.}.
En otras ocasiones es gente desinteresada que quiere ayudar a que otras personas disfruten el título.

En ambos casos, este tipo de traducciones como se comentó en la traducción perjudica a la compañía y es esta la mediante los mecanismos descritos a continuación intenta poner trabas para al menos retrasar estas traducciones y dar tiempo a que salgan las oficiales.

Los textos que aparecen en diálogos y menús, al igual que aquellos nombres para denominar a \textit{Pokémons} y ataques son el primer objetivo a la hora de realizar una traducción o edición.
Es por ello que son estos los archivos más protegidos con cifrados u ofuscado de nombre como se verá.
Cuando mayor sea la protección menos usuarios tendrán las capacidades y más esfuerzo requerirá.
De nuevo se trata el problema descrito en el segundo capítulo donde se valora si es el esfuerzo necesario compensa el resultado final.

El único tipo de fichero que se ha podido comprobar que en ningún caso llega a ser protegido son es la música y efectos de sonido del juego, estando en un formato estándar con extensión \textsf{.sdat} en la carpeta raíz del juego.

\subsection{Pokémon Perla y Diamante}
El par de juegos \textit{Pokémon Diamante y Perla} corresponden a la cuarta generación de saga y a la primera que salió para \acl{NDS}.
El primer país en recibirlos fue Japón a finales de septiembre de 2006 y como es frecuente mucho después llegó al resto del mundo.
Concretamente pasaron siete meses hasta la llegada a Estados Unidos y tres meses más hasta la llegada a Europa.

\subsubsection{Archivos}
Se trata del primera generación de juegos que llegan a esta consola donde como característica importante respecto a su antecesora (\acl{GBA}) es la introducción del sistema de ficheros.
En estos tres juegos, los archivos dentro del juego tienen nombres explicativos sobre su contenido (figura~\ref{fig:tr-pearlfiles}).
Ejemplo son ficheros como \textit{msgdata/msg.narc} con los mensajes o textos del juego, \textit{itemtool/itemdata/item\_icon.narc} con las imágenes de los objetos o \textit{graphic/font.narc} con las tipografías del juego.

\includefigure{fig:tr-pearlfiles}%
{Sistema de ficheros en Pokémon Perla visto con Tinke}%
{imgs/TR-PearlFiles.png}

\subsubsection{Textos}
\label{sec:tr-pok-pearl-text}
Centrándose en textos del juego se comprueba que están cifrados.
Tras una búsqueda de las frases de diálogos iniciales sobre todo el archivo binario del juego no se encuentran resultados.
Se probó en las codificaciones más frecuentes de esta consola como son ASCII y UNICODE sin resultado.
Esto indica que bien el archivo que contiene los textos está comprimido o cifrado.

El siguiente procedimiento fue extraer la memoria RAM del juego justo en el momento de mostrar ese diálogo, pues debería estar almacenada esa frase para poder ser mostrada en pantalla.
Esto se puede realizar gracias al emulador DeSmuME mencionado en el capítulo~\ref{sec:requirements}.
Una vez extraído el archivo binario con la memoria RAM, mediante visores hexadecimales se buscó la frase que aparecía en pantalla usando las codificaciones estándar y sin obtener resultado de nuevo.
Dado que la frase ha de estar en la memoria RAM, el problema era por tanto que no estaba usando una codificación estándar.
Existen dos procedimientos básicos para realizar una búsqueda en estos casos.

El primero consiste en buscar el archivo con la tipografía del juego, pues la codificación será la misma que el orden con el que aparecen los caracteres en ella.
En la tabla~\ref{tab:tr-pearlfont} se especifica el formato usado en este juego para estos archivos.
% TODO: Crear plugin de Tinke para exportarla.
% TODO: Añadir imagen de la tipografía extraída.

\ctable[
    caption = Especificación de tipografías en Pokémon Perla,
    label   = tab:tr-pearlfont,
    pos     = h
]{ccl}{
    \tnote[a]{Los caracteres están codificados por \textit{tiles} de 8$\times$x8 píxeles en formato horizontal.}
    \tnote[b]{Cada byte indica el ancho del caracter.}
}{                                                                      \FL
    Posición      & Tamaño        & Descripción                         \ML
    \multicolumn{3}{c}{Cabecera}                                        \NN
    \textsf{0x00} & \textsf{0x04} & Puntero a la sección de datos       \NN
    \textsf{0x04} & \textsf{0x04} & Puntero a la sección \acs{VWT}      \NN
    \textsf{0x08} & \textsf{0x04} & Número de caracteres                \NN
    \textsf{0x0C} & \textsf{0x01} & Ancho de un caracter                \NN
    \textsf{0x0D} & \textsf{0x01} & Alto de un caracter                 \NN
    \textsf{0x0E} & \textsf{0x01} & BPP                                 \NN
    \textsf{0x0F} & \textsf{0x01} & BPP                                 \ML
    \multicolumn{3}{c}{Datos de la fuente\tmark[a]}                     \ML
    \multicolumn{3}{c}{\ac{VWT}\tmark[b]}                               \LL
}

El segundo procedimiento posible es el de desarrollar un programa de búsqueda diferencial. Con motivo de este trabajo en el capítulo~\ref{sec:requirements} se explica el programa \textit{RelativeSearch} que se llevó a cabo. Este tipo de \textit{software} se puede usar siempre y cuando el orden de los caracteres de un mismo grupo (por ejemplo letras minúsculas) corresponda a estándares como ASCII. Si se hubiese seguido un orden aleatorio en la codificación propietaria este no serviría quedando la primera opción como única alternativa.

Tras usar cualquiera de los dos procedimientos anteriormente descritos, se puedo encontrar una coincidencia en la memoria RAM del diálogo. El siguiente paso consistió en depurar el juego para hallar el algoritmo de descifrado o descomprensión de textos. Para ello usando los programas descritos en el capítulo~\ref{sec:requirements} de depuración, se puso un punto de interrupción en dicha posición.

Cabe destacar que esta posición es dinámica por lo que cambia cada vez que se inicia el juego pues depende de muchas variables. Para sortear este problema se hizo uso de los \textit{savestates} del emulador, es decir guardados de memoria del juego que permiten ir a cualquier momento de una ejecución. Gracias a esta característica se puede realizar un guardado justo antes de que el juego guarde un juego de forma que siempre que se use ese \textit{savestate} encontraremos el texto en la misma posición. El punto de interrupción hizo parar el emulador justo en las instrucciones máquinas que estaban realizando, en este caso, el descifrado. Este algoritmo se describe a continuación.

El texto se encuentra cifrado usando la operación XOR y mediante una clave que se actualiza después de descifrar cada byte\footnote{Al no ser una clave constante no se puede obtener esta al ser aplicada sobre zonas con valores a 0 como sí sucede en el caso de la tabla de contenido.}. La clave inicial es igual a \verb!clave = (ushort)(0x91BD3 * (i + 1))! donde \verb!i! es el bloque de texto a descifrar. Después de aplicar la clave sobre un byte esta se actualiza según \verb!clave = (ushort)(clave + 0x493D)!.

El cifrado no es exclusivo del texto pues la tabla de contenido con las posiciones y tamaños de cada diálogo se encuentra cifrado también. La clave no coincide con la del texto y se forma de la siguiente manera: \verb!clave = (ushort)(clave_base * 0x2FD * (i + 1))!. En este caso, se hace uso de una clave base que se encuentra disponible en la cabecera del fichero y de nuevo con número de entrada a descifrar (\verb!i!). Dado que el tamaño de estos campos cifrados es de 32 bits y la clave de 16 bits, se concatena la clave dos veces formando el valor de 32 bits necesario para aplicar la operación XOR. % chktex 13

Sin embargo, esta parte del fichero a pesar de estar cifrado presenta un fallo de seguridad. Como se ha comentado los valores cifrados de posición y tamaño son de 32 bits (4 bytes) pero en la mayoría de los casos solo se usan los dos primeros bytes pues tamaño del fichero de texto no supera los \verb!2^16 = 65535 bytes!. Debido a la concateniación de la clave y a que los dos últimos bytes son 0, al cifrar estos dos bytes se estuvo guardando la clave en texto plano.
Es decir, se demuestra que \verb!a XOR 0 = a! siendo en este caso \verb!a! la clave para cifrar estas entradas y el valor guardado en el fichero en la mayoría de los casos.

En la tabla~\ref{tab:tr-pearltxt} se especifica el formato de los archivos de texto.

\ctable[
    mincapwidth = 110 mm,
    footerwidth,
    caption = Especificación del formato de texto en Pokémon Perla,
    label   = tab:tr-pearltxt,
    pos     = h,
]{ccl}{
    \tnote[a]{Se especifica solo la primera entrada.}
    \tnote[b]{Campo cifrado descrito en la sección~\ref{sec:tr-pok-pearl-text}.}
}{                                                                      \FL
    Posición      & Tamaño        & Descripción                         \ML
    \multicolumn{3}{c}{Cabecera}                                        \NN
    \textsf{0x00} & \textsf{0x02} & Número de bloques de texto          \NN
    \textsf{0x02} & \textsf{0x02} & Clave base para descifrar \acs{TOC} \ML
    \multicolumn{3}{c}{\acl{TOC}\tmark[a]}                              \NN
    \textsf{0x00} & \textsf{0x04} & Posición del texto\tmark[b]         \NN
    \textsf{0x04} & \textsf{0x08} & Tamaño del texto\tmark[b]           \ML
    \multicolumn{3}{c}{Texto\tmark[b]}                                  \LL
}

\subsubsection{Imágenes}
\label{sec:tr-pok-pearl-img}
En el caso de la saga de Pokémon las imágenes no contienen frases con texto por lo que en cuanto a una traducción respecta no son necesarias editarlas.
Sin embargo, dada la popularidad de los \textit{mods} y de la extracción de imágenes en estos juegos se apostó por cifrar un tipo concreto de las mismas.
Se trata de los \textit{sprites} de los \textit{Pokémons} que aparecen durante las batallas.
Estos archivos están contenidos en el paquete \textit{poketool/pokegra/pokegra.narc} donde hay seis imágenes por monstruo.

El cifrado se realizó sobre los datos de la imagen, manteniendo las cabeceras del formato de la misma sin cifrar.
Como consecuencia, las imágenes se podían abrir usando programas estándares pero sin ver nada en concreto.
% TODO: Hacer programa y descifrar una imagen y poner comparativa

El procedimiento para encontrar el algoritmo de cifrado en este caso es distinto al realizado con texto.
No se puede partir de datos conocidos como anteriormente se partía de una frase que se veía en la pantalla.
Sin embargo, dado que las cabeceras de la imagen no están cifradas se pudo buscar sobre el código en ensamblador la función que procesa esta cabecera.
En concreto se buscó la palabra mágica \textsf{CHAR} que se procesaa para determinar el comienzo de una sección del archivo.

Una vez encontrado la función que lee una imagen, solo habría que acceder a una parte del juego donde se esperaba que se cargase una imagen como durante una batalla y poner un punto de interrupción sobre esta función.
Tras omitir imágenes que no estaban cifradas\footnote{Dado que una imagen contiene suele tener píxeles cercanos de igual colores, siempre que en los datos se observara patrones se podía determinar que no estaba cifrada.}, se llegó a una que sí lo estaba donde se puso un punto de interrupción.

La siguiente función que leía los datos de dicha imagen era el algoritmo de descifrado. Este algoritmo parte del hecho que todo el bloque de datos de una imagen tendrá el tamaño constante de \textsf{0x1900} bytes.
Se trata de un cifrado parecido al realizado sobre el texto donde habrá una clave que irá cambiando después de aplicarse sobre cada valor y que se usará para aplicar la operación XOR sobre un dato cifrado.
En este caso, la clave es de 32 bits y el dato a descifrar de 16 bits y se comencerá desde el final del fichero hasta el principio.
La clave inicial será el primer valor (últimos dos bytes del fichero) e irá cambiando siguiendo la siguiente operación \verb!clave = (uint)(clave * 0x41C64E6D + 0x6073)!.

\subsubsection{Conclusión}

\begin{tabular}{p{0.4\textwidth}p{0.5\textwidth}}
Pros & Contras \\
% Pros
\begin{itemize}
\item Los textos usando una codificación no estándar.
\item Los textos están cifrados con una clave no estática.
\item Las imágenes están cifradas con un clave no estática.
\end{itemize} &

% Contras
\begin{itemize}
\item Los archivos y carpetas tienen nombres descriptivos.
\item Hay un fallo de seguridad en el cifrado de la tabla de contenido de los textos por el que se puede averiguar la clave.
\end{itemize} \\
\end{tabular}

\subsection{Pokémon HeartGold y SoulSilver}
Los juegos \textit{Pokémon HeartGold y SoulSilver} son las siguiente generación de la saga que salieron también para \acl{NDS}.
Se repite como es común el orden y plazo de lanzamiento. De esta forma se lanzó primero en Japón a mediados de septiembre de 2009, a continuación en América seis meses después, en abril de 2010, y finalmente en Europa una semana después.

Esta vez no hubo mucha diferencia entre los lanzamientos de América y Europa lo que provocaría que no fuese necesario realizar traducciones no oficiales desde el inglés, idioma desde el cual al ser más sencillo se parten la mayoría de las traducciones.
Sin embargo, sí hubo traducciones que partieron del japonés y que se quedaron entorno a un 90\% de finalización~\cite{PokProj-HG1}.

\subsubsection{Archivos}
\label{sec:tr-pok-heart-file}
La primera gran diferencia en esta generación llega con el ofuscado de nombres de archivos y directorios. Como se puede apreciar en la figura~\ref{fig:tr-heartfiles} todos los archivos principales del juego están nombrados con números y clasificados en carpetas númericas también.
Además, el contenido de estas carpetas no relaciona a los archivos entre sí generando una organización aleatoria.
En total hay 275 archivos que a su vez son contenedores de subarchivos sin nombre.
Estos contenedores pueden llegar a tener más de 1000 archivos en su interior pero si se garantiza que el contenido de estos está relacionado entre si correspondiendo a las imágenes a las características de \textit{Pokémon} o las imágenes de un menú concreto.

\includefigure{fig:tr-heartfiles}%
{Carpetas y ficheros ofuscados en Pokémon HeartGold}%
{imgs/TR-HeartFiles.png}

Mediante depuración del código ensamblador se pudo comprobar la implementación del acceso a estos archivos.
Todo se realiza llamando a varias funciones de similar cometido cuyo primer parámetro es un ID que identifica al archivo y como segundo parámetro el sub-archivos dentro del contenedor.
Este ID es lineal y si se descompone en base diez se puede calcular la ruta absoluta.
De esta forma el ID \textsf{0x1B} (27) corresponde a \verb!27 = 0*10 + 2*10 + 7! lo que significa que estaría ubicado en \textit{a/0/2/7}.
A la hora de implementar este mecanismo durante el desarrollo del videojuego se usuaría un archivo de cabeceras similar al siguiente.

\begin{verbatim}
file_paths.h
#define MESSAGE_FILE_ID 0x1B
#define POKEMON_IMAGES_FILE_ID 0x1C
\end{verbatim}

De esta manera, en el proceso de desarrollo sería fácil y sin ofuscar su propio código el indicar qué fichero cargar usando las constantes definidas.
Este método es sencillo de implementar y dificulta la tarea de edición del juego pues entre los 275 archivos disponibles, binarios, sin estructuras de datos conocidas, habría que averiguar qué hace cada uno sin tener una pista previa como pasaba en ediciones anteriores donde el nombre era descriptivo del contenido.

\subsubsection{Textos}
Los textos de esta generación vienen igualmente cifrados.
Esto se pudo comprobar al realizar de nuevo una búsqueda de palabras de los primeros diálogos y no tener resultados ni en el archivo binario del juego ni sobre la memoria RAM.

Tras repetir el proceso descrito en la sección~\ref{sec:tr-pok-pearl-text} de textos de la generación anterior, se comprobó que tanto el formato del archivo como el algoritmo de cifrado y claves son exactamente las mismas a las descritas ahí. Además el formato de las fuentes es también el mismo.

En esta nueva generación no se apostó por cambiar el cifrado de textos y delegar toda la responsabilidad de dificultar la tarea de edición en el ofuscamiento de nombres de ficheros. El fichero está localizado en \textit{a/0/2/7}.

\subsubsection{Imágenes}
Al igual que sucede con los textos, tras repetir los pasos de la sección~\ref{sec:tr-pok-pearl-img} de imágenes se descubrió que se utiliza el mismo algoritmo de cifrado con las mismas claves. Se encontró sin embargo, una diferencia en la implementanción pues en este caso se descifra empezando por el comienzo de los datos en lugar de por el final.

\subsubsection{Conclusión}

\begin{tabular}{p{0.4\textwidth}p{0.5\textwidth}}
Pros & Contras \\
% Pros
\begin{itemize}
\item Los archivos están ofucados por nombre y directorio.
\end{itemize} &

% Contras
\begin{itemize}
\item No todos los archivos están ofuscados como se ve en la siguiente apartado.
\item Se mantiene los mismos algoritmos y claves que en la generación anterior por lo que una vez encontrado los archivos se pueden reutilizar las mismas herramientas.
\end{itemize} \\
\end{tabular}

\subsection{Pokémon Blanco y Negro}
La sexta generación corresponde a los juegos \textit{Pokémon Blanco y Negro} para la \acl{NDS}.
Primero salieron en Japón a mediados de septiembre de 2010 y a principios de marzo de 2011 en América y Europa.
Esta vez, como curiosidad, el juego salió por primera vez dos días antes en Europa que en el resto de sitios.

De nuevo esta edición fue esperada por muchos seguidores que unido con el avance que hay en el mundo de la ingeniería inversa para la \acl{NDS} en estos años, facilitó la tarea de traducción no oficial~\cite{PokProj-BW1}.
No solo llegaron a salir traducciones al inglés si no también a otros idiomas como español.
Todas ellas se llevaron a cabo de forma transparente y colaborativa mediante GitHub\footnote{\url{https://github.com/projectpokemon/Pokemon-Black-White-Translation-Files}}.

\subsubsection{Archivos}
En la sexta generación decidieron optar de nuevo por ofuscar los nombres de las carpetas y archivos.
En este caso, se dio un paso más y se hizo sobre todos los archivos.
Sin bien, en el caso de \textit{Pokémon HeartGold y SoulSilver} fueron solo los archivos principales los ofuscados, en esta edición los únicos que no se procesaron fueron los de sonido y demo como se aprecia en la figura~\ref{fig:tr-blackheartfiles}.

\includefigure{fig:tr-blackheartfiles}%
{Comparación de carpetas entre Pokémon Blanco (izq.) y Pokémon HeartGold (der.)}
{imgs/TR-BlackHeartFiles.png}

A pesar de usar internamente la misma forma de acceso a como se describió en el apartado de archivos de la sección~\ref{sec:tr-pok-heart-file}, los identificadores y por tanto localización de estos cambió.
Pasando de esta forma el archivo con los textos del juego a estar en \textit{a/0/0/2} en lugar de \textit{a/0/2/7} como sucedía en la edición anterior.

\subsubsection{Textos}
\label{sec:tr-pok-black-text}
En el apartado de protección a los textos, en las dos generaciones anteriores se utilizó un mismo algoritmo basado en un clave dinámica que se aplicaba con la operación XOR. En esta generación la filosofía del algoritmo se mantiene cambiando no obstante la forma de generación y actualización de la clave.
Esta se pudo obtener tras realizar el procedimiento descrito en el apartado textos de la sección~\ref{sec:tr-pok-pearl-text}.

La principal diferencia tras aplicar el método de investigación de cifrado fue ver que no se usaba una codificación propia si no UTF-16.
Esto facilitó la tarea, pues ya no es necesaria una búsqueda diferencial en la memoria RAM y por tanto crear \textit{software} adicional para investigar.
Se trata por tanto de la eliminación de un mecanismo fuerte a la hora de proteger datos que posiblemente estaba realizando en ediciones anteriores de casualidad.

La clave inicial usada para el texto se genera usando el número de bloque como variable, de forma que cada bloque comienza con una clave diferente. La operación es \verb!clave = (i + 3) * 0x2983!.
Tras aplicar esta clave sobre un valor de 16 bits cifrado (dos bytes), se actualiza desplazando los tres bits más significados a la posición menos significativa.
Esto se puede conseguir aplicando la siguiente serie de operaciones.

\begin{verbatim}
temp  = clave & 0x1FFF;             // Elimina los bits más significativos
clave = (temp << 3) | (clave >> 13) // y los añade al principio.
\end{verbatim}

Al desplazarse un número impar de veces, cada bit pasará de forma lineal sobre cada posición de la clave obteniéndose el máximo de permutaciones para una clave de 16 bits, es decir se usará a la hora de cifrar y descifrar 16 claves diferentes.

La estructura de datos se especifica en la tabla~\ref{tab:tr-blacktxt} donde se puede ver que la sección con la tabla de contenido no está cifrada a diferencia de cómo pasaba en ediciones anteriores.

\ctable[
    mincapwidth = 110 mm,
    footerwidth,
    caption = Especificación del formato de texto en Pokémon Blanco,
    label   = tab:tr-blacktxt,
    pos     = h,
]{ccl}{
    \tnote[a]{Se especifica solo la primera entrada.}
    \tnote[b]{Cada caracter es un valor de 16 bits.}
    \tnote[c]{Campo cifrado descrito en la sección~\ref{sec:tr-pok-black-text}.}
}{                                                                          \FL
    Posición      & Tamaño        & Descripción                             \ML
    \multicolumn{3}{c}{Cabecera}                                            \NN
    \textsf{0x00} & \textsf{0x02} & Constante: \textsf{0x01}                \NN
    \textsf{0x02} & \textsf{0x02} & Número de bloques de texto              \NN
    \textsf{0x04} & \textsf{0x04} & Tamaño de la sección de datos           \NN
    \textsf{0x08} & \textsf{0x04} & Constante: \textsf{0x00}                \NN
    \textsf{0x0C} & \textsf{0x04} & Tamaño de la cabecera                   \ML
    \multicolumn{3}{c}{Datos}                                         \NN
    \textsf{0x00} & \textsf{0x04} & Tamaño de la sección                    \NN
    \textsf{0x04} & \textsf{0x04} & Posición relativa a la sección\tmark[a] \NN
    \textsf{0x06} & \textsf{0x02} & Número de caracteres\tmark[a]\tmark[b]  \NN
    \textsf{0x08} & \textsf{0x02} & Desconocido\tmark[a]                    \ML
    \multicolumn{3}{c}{Texto\tmark[c]}                                      \LL
}

\subsubsection{Imágenes}
Las imágenes a diferencia de las pasadas generaciones no se cifraron.
En cambio, no se utiliza un formato estándar de codificación.
Si bien el formato para las paletas y datos de imagen si se reutiliza y sigue siendo estándar, existe un ficheros extras con una especificación nueva en este juego con la información necesaria para recomponer la imagen (figura~\ref{fig:tr-blackimg}).

\includefigure{fig:tr-blackimg}%
{Imágenes sin cifrar en Pokémon Negro.}%
{imgs/TR-BlackImg.png}

Esta forma de codificación, aunque pudiendo no ser específica para protegerlas ante modificaciones si no un requisito para animaciones, es más fuerte.
De esta forma los programas de ediciones genéricas creados para juegos de \acl{NDS} ya no son útiles y se necesita nuevos y específicos.
Esta tarea requiere de investigación de formatos y de programación, algo que toma más esfuerzo y tiempo que crear un decodificador como pasaba en las generaciones anteriores.

A pesar de ello, esta reconstrucción y edición de la imagen se podría llegar a cabo manualmente ya que el formato de los ficheros principales: paleta y datos de imagen, sigue siendo el estándar para juegos de la \acl{NDS}.

\subsubsection{Conclusión}

\begin{tabular}{p{0.4\textwidth}p{0.5\textwidth}}
Pros & Contras \\
% Pros
\begin{itemize}
\item Los nombres de las carpetas y archivos están ofuscados.
\item Los textos están cifrados con un nuevo algoritmo y clave.
\item Las imágenes usan archivos extras con especificaciones nuevas para recomponerlas por lo que \textit{software} nuevo sería necesario.
\end{itemize} &

% Contras
\begin{itemize}
\item Los textos no usan una codificación propia.
\item Las imágenes no está cifradas.
\item Las imágenes usando el formato estándar para los archivos principales.
\end{itemize} \\
\end{tabular}

\subsection{Pokémon Conquest}
\textit{Pokémon Conquest} es un juego desarrollado por \textit{Tecmo Koei} y publicado en el año 2012 para la consola \acl{NDS}.
Este juego dista de la mecánica de la saga principal pues se trata de un género de combates por turnos y estrategia en lugar de RPG. Primero se distribuyó en Japón a mediados de marzo, y a pesar de que tardaron meses en confirmarlo, en junio y julio del mismo año se lanzó en América y Europa.

Esta falta de confirmación inicial hicieron incluso tres días antes del lanzamiento se formara un grupo de traducción no oficial con el objetivo de ofrecer una jugabilidad parcial lo más pronto posible~\cite{PokCheat-Conq}.
Esta traducción llegó a casi completarse al inglés en cuanto a la trama principal y listas de nombres.
Además surgieron a partir de esta varias a otros idiomas como italiano y alemán.

\subsubsection{Archivos}
En este juego no se han ofuscado los archivos y carpetas.
Todo está bien organizado y con nombres descriptivos.

\subsubsection{Textos}
\label{sec:tr-pok-conquest-text}
Los textos sí han cifrado y codificado con una protección mayor que en otras generaciones.
Para encontrar se buscó en primer lugar sobre la memoria RAM repitiendo el proceso explicado en el apartado textos de la sección~\ref{sec:tr-pok-pearl-text}.
Dado que se usa la codificación estándar SJIS se pudo encontrar directamente.

Una vez puesto el punto de interrupción se dio con el algoritmo que descodifica estos caracteres.
Con el objetivo de ahorra espacio y ofuscar el texto los archivos de textos tienen una codificación especial basada en caracteres de control y optimizada para caracteres japoneses.
Su sistema se basa en especificar solo un byte por caracter japonés en lugar de dos como dice SJIS.
El segundo caracter restante al estar comprendido entre \textsf{0x81--0x83} y es igual entre caracteres cercanos, se va predice mediante unos códigos de control.
Esta codificación está implementada en ambos sentidos en el proyecto AmbitionText\footnote{\url{http://subirelcodigo}}.
Destaca esta codificación pues no es sencilla de implementar y requiere mucho esfuerzo de creación de una herramienta que permita trabajar con ella.

Antes de esta parte de codificación, el texto se descifra.
El cifrado se basa en aplicar la clave ``\textsf{MsgLinker Ver1.00}'' sobre cada byte de texto.
A continuación se muestra la implementación en C\# para el cifrado y descifrado\footnote{\url{http://subirelcodigo}}.
El formato del fichero se especifica en la tabla~\ref{tab:tr-conquesttxt}.

\begin{verbatim}
string key = "MsgLinker Ver1.00";
for (int i = 0; i < data.Length; i++)
    data[i] ^= key[i % key.Length];
\end{verbatim}

\ctable[
    caption = Especificación del formato de texto en Pokémon Conquest,
    label   = tab:tr-conquesttxt,
    pos     = h,
]{ccl}{
    \tnote[a]{Se especifica solo la primera entrada.}
    \tnote[b]{Existen 33 bloques.}
    \tnote[c]{Campo cifrado descrito en la sección~\ref{sec:tr-pok-conquest-text}.}
}{                                                                          \FL
    Posición      & Tamaño        & Descripción                             \ML
    \multicolumn{3}{c}{\acl{TOC}\tmark[a]\tmark[b]}                         \NN
    \textsf{0x00} & \textsf{0x04} & Posición del bloque                     \NN
    \textsf{0x04} & \textsf{0x04} & Tamaño del bloque                       \ML
    \multicolumn{3}{c}{Bloques\tmark[c]}                                    \LL
}

\subsubsection{Imágenes}
Tanto los fondos como los \textit{sprites} del juego no vienen cifrados.
Sin embargo se usan formatos de ficheros nuevos, con codificaciones nuevas que supusieron un trabajo extra de creación de \textit{software}\footnote{\url{https://github.com/pleonex/tinke/tree/master/Plugins/PSL}}.

\subsubsection{Conclusión}

\begin{tabular}{p{0.4\textwidth}p{0.5\textwidth}}
Pros & Contras \\
% Pros
\begin{itemize}
    \item Los textos vienen cifrados y codificados.
    \item La codificación es única para este juego.
    \item Nuevos formatos de imágenes que requieren nuevos programas.
\end{itemize} &

% Contras
\begin{itemize}
    \item Los archivos y carpetas no están ofuscados.
    \item Se usa una codificación final estándar.
    \item Las imágenes no están cifradas.
\end{itemize} \\
\end{tabular}

\section{Ninokuni y el Mago de las Tinieblas}
\textit{Ni no Kuni: Shikkoku no Mad?shi} es el título original de un juego que solo llegó a Japón de la mano de \textit{Level-5} para la consola \acl{NDS} en 2010.
Desde su salida, debido a que el juego se distribuía junto a un libro físico, se confirmó que iba a poder salir de este país debido a los costes de producción y traducción que supondría el libro.

Es por ello, que a finales de 2011 un grupo denominado GradienWords\footnote{\url{http://gradienwords.com}} se formó con el objetivo de realizar una traducción altruista del juego.
Este proyecto terminó a finales de mayo de 2015 e incluye tanto el juego como una copia del libro en PDF traducida.
Con fecha de este trabajo este es el único proyecto de traducción de este juego que se ha finalizado, a pesar de que están en marcha varios al francés, inglés e italiano\footnote{\url{http://gbatemp.net/forums/nds-rom-hacking-and-translations.41/}}.

El juego se llegó a lanzar previamente en \acl{PS3} en varios idiomas incluyendo el español pero no llegó con la copia física del libro y tanto la mecánica del juego como la historia se cambiaron.

La protección encontrada en este juego muestra no se concentra en evitar una traducción, posiblemente porque la compañía sabía que ellos no lo iban a hacer, si no modificaciones del juego.
De esta forma se aprecia como los archivos que contienen parámetros como características de los monstruos, de ataque y batalla sí están cifrados.
Además de como se explicará el archivo de guardado también presenta un algoritmo de integridad.

\subsubsection{Archivos}
Los archivos y carpetas no están ofuscadas y está todo bien organizado y clasificado.

\subsubsection{Textos}
En cuanto al apartado de textos hay que distiguir de dos tipos: \textit{scripts} y nombres y descripciones.
Empezando por el último, este tipo de textos se encuentran en archivos que contienen las características de personajes, objetos y ataques y no solo el texto.
Con el objetivo de editar los parámetros que definen sus características y hacer una versión modificada del mismo con mayor, menor o una jugabilidad distinta estos ficheros se cifraron.
El cifrado es muy básico y pero eficaz ante personas que no entienden.
En la figura~\ref{fig:tr-nino-minitext} se puede ver como se repite el byte \textsf{0xFF} con frecuencia.
Esto da una pista del tipo de cifrado empleado pues probando a realizar una operación \textsf{XOR 0xFF} o lo que es lo mismo \textsf{NOT} se puede ver como todo queda descifrado.

\includefigure{fig:tr-nino-minitext}%
{Archivo cifrado (arr.) y descifrado (ab.) de Ninokuni y el Mago de las Tinieblas}%
{imgs/TR-NinoMiniText.png}

Respecto a los \textit{scripts} debido a sus requisitos técnicos para ejecutar todo tipo de comandos son complejos de investigar.
A día de hoy solo existe un \textit{software} no público desarrollado para la traducción al español que solo es capaz de editar los textos de los diálogos.
El formato está basado en parámetros a nivel de bits lo que hace inviable investigar el formato sin mirar las instrucciones máquinas del juego que lo procesan.

\subsubsection{Imágenes}
Las imágenes no están cifradas pero los archivos asociados a una imagen están comprimidos en un nuevo formato.
Son fáciles de extraer pero requiere nuevo \textit{software}\footnote{\url{https://github.com/pleonex/ninoimager}}.

\subsubsection{Integridad en archivos de guardado}
En este videojuego se ha estudiado adicionalmente los mecanismos de protección en el archivo con los datos de guardado.
Se trata de un fichero que en los cartuchos originales no se puede editar sin poseer \textit{hardware} adicional pero que en una \textit{flashcard} se trata de un fichero común, en este caso de 64 KB, y que por tanto es accesible y fácil de editar de forma no autorizada.

Para evitar esto mismo, en lugar de cifrar se ha apostado por implementar un algoritmo de integridad.
Para encontrarlo se buscó en la memoria RAM extraída con el emulador DeSmuME, los datos de este archivo.
Una vez localizada la parte de la memoria que contiene el archivo, se puso un punto de interrupción en los primeros bytes para conocer qué operaciones se realizan sobre los mismos.

En primer lugar se comprueba que el primer valor de 16 bits sea \textsf{0x0028} y que los últimos ocho bytes sean en hexadecimal \textsf{0B 3F A5 84 EC 32 9A 7D}.
A continuación sobre el resto de los datos, desde la posición \textsf{0x0002} hasta \textsf{0xFFE4} se calcula un hash usando el algoritmo SHA-1.
Para añadir seguridad e imposibilitar la edición sin conocer todos los detalles de la implementación, lo requiere mirar estas instrucciones máquinas, en la posición \textsf{0xC5EC} durante el cálculo del hash se escriben los bytes en hexadecimal \textsf{6E 6B 6E 6E} (en ASCII y \textit{low-endian} equivalen a las consonantes del nombre del juego `\textit{nnkn}').
Se trata de una clave que sin conocer ni su valor ni su posición sería imposible calcular un código SHA-1 válido.
Este hash se guarda en la posición \textsf{0xFFE4} del archivo de guardado y durante el inicio del juego se comprueba.
En caso de no ser válido el mensaje muestra un mensaje de error y borra todos los datos de la partida.

\includefigure{fig:tr-ninosaveinvalid}%
{Mensaje de error al detectar una partida modificada (izq.) y advertencia (der.).}%
{imgs/TR-NinoSaveInvalid.png}

\subsubsection{Conclusión}

\begin{tabular}{p{0.4\textwidth}p{0.5\textwidth}}
Pros & Contras \\
% Pros
\begin{itemize}
    \item Formato complejo en los \textit{scripts}.
    \item Cifrado básico en algunos archivos de texto.
    \item Mecanismo de integrida en el archivo de guardado.
\end{itemize} &

% Contras
\begin{itemize}
    \item En general los archivos no están cifrados los archivos de texto.
    \item Las imágenes no están cifradas.
\end{itemize} \\
\end{tabular}

\section{Proyectos abandonados}
Para terminar se incluye un estudio sobre los proyectos de traducciones no oficiales que han sido abandonados con fecha de este trabajo y con sus respectivos motivos.
El estudio se ha centrado en juegos para la \acl{NDS} a partir de~\cite{GTemp-Aband} y~\cite{RH-Aband}.

El objetivo será el de mostrar las causas más frecuentes que como se verá en la mayoría de los casos fue por la confirmación de una localización al idioma de la traducción.

\subsubsection{Ausencia de \textit{software} de edición}
Surgidos por la falta de personal con conocimientos técnicos y de programación que puedan crear los programas necesarios de edición.
\begin{itemize}
\item WWII-Tank Battles (\acs{PS2}): Ausencia de descompresor de archivos.
\item Chi's Sweet Home: Chi ga Ouchi ni Yatte Kita! (\acs{NDS}): Ausencia de importador de imágenes.
\item Brave Fencer Musashi (\acs{PSX}): Ausencia de editor de textos.
\item Code Geass: Hangyaku no Lelouch (\acs{NDS}): Ausencia de editor de textos.
\item Custom Beat Battle Draglade 2 (\acs{NDS}): Ausencia de editor de textos.
\item Mobile Suit Gundam 00 (\acs{NDS}): Ausencia de editor de textos.
\item Super Robot Taisen OG Saga: Mugen No Frontier (\acs{NDS}): Ausencia de editor de textos.
\item Mysterious Dungeon: Shiren the Wanderer 2 (\acs{NDS}): Ausencia de editor de textos y de modificaciones técnicas necesarias sobre el juego.
\end{itemize}

\subsubsection{Problemas técnicos tras editar el juego}
Problemas surgidos durante la traducción que no se solucionaron debido a falta de conocimientos o abandono de soporte de quienes crearon las herramientas.
\begin{itemize}
\item Dai Kaijuu Monogatari (\acs{PSX}): Los programas usados para editar los textos causan bloqueos en el juego.
\item Resident Evil 2 (\acs{DC} y \acs{GC}): El compresor de archivos creado no funcionaba con todos.
\end{itemize}

\subsubsection{Abandono personal}
Causado en su mayoría por una falta de motivación y tiempo del equipo que lo llevaba a cabo.
\begin{itemize}
\item Professor Layton: London Life (\acs{NDS}).
\item Cross Treasures (\acs{NDS}).
\item Element Hunters (\acs{NDS}).
\item Hajime no Ippo The Fighting! DS (\acs{NDS}).
\item Naruto: Ninja Destiny 3 (\acs{NDS}).
\item Super Robot Wars K (\acs{NDS}).
\end{itemize}

\subsubsection{Traducción oficial}
Abandonos de proyectos por la llegada o confirmación de una traducción oficial.
\begin{itemize}
\item Final Fantasy: The 4 Warriors of Light (\acs{NDS}). Traducción inglesa.
\item Fire Emblem: Shadow Dragon (\acs{NDS}).
\item Glory of Heracles (\acs{NDS}).
\item Inazuma Eleven (\acs{NDS}).
\item Kindom Hearts 356/2 Days (\acs{NDS}).
\item Naruto: Ninja Destiny 2 (\acs{NDS}).
\item Nostalgia (\acs{NDS}).
\end{itemize}

Se puede ver que el problema más común está la falta de programas de edición de juegos concretos.
Para poder llevar a cabo esto hace falta unos conocimientos técnicos tanto de \textit{software} como de \textit{hardware} y de una larga experiencia.
Es por esto que a la hora de empezar un proyecto la parte técnica suele ser la más complicada de resolver y que en muchos casos nunca se llega a resolver del todo.

La segunda causa más frecuente es la confirmación de la llegada de una localización, suficiente motivo para parar el proyecto y no dañar los intereses de mercado de una empresa.
