% Copyright (c) 2015 Benito Palacios Sánchez - All Rights Reserved.
% Esta obra está licenciada bajo la Licencia Creative Commons Atribución 4.0
% Internacional. Para ver una copia de esta licencia, visita
% http://creativecommons.org/licenses/by/4.0/.

\chapter{Traducciones no oficiales y mods}
\label{sec:translations}

% TODO: Introducción de traducciones no oficiales y mods

\section{Saga Pokémon en \acl{NDS}}

% TODO: Introducción de Pokémon

Los textos que aparecen en diálogos y menús, al igual que aquellos nombres para denominar a \textit{Pokémons} y ataques son el primer objetivo a la hora de realizar una traducción.

\subsection{Pokémon Perla y Diamante}
El par de juegos \textit{Pokémon Diamante y Perla} corresponden a la cuarta generación de saga y a la primera que salió para \acl{NDS}.
El primer país en recibirlos fue Japón a finales de septiembre de 2006 y como es frecuente mucho después llegó al resto del mundo.
Concretamente pasaron siete meses hasta la llegada a Estados Unidos y tres meses más hasta la llegada a Europa.

\subsubsection{Archivos}
Se trata del primera generación de juegos que llegan a esta consola donde como característica importante respecto a su antecesora (\acl{GBA}) es la introducción del sistema de ficheros.
En estos tres juegos, los archivos dentro del juego tienen nombres explicativos sobre su contenido (figura~\ref{fig:tr-pearlfiles}).
Ejemplo son ficheros como \textit{msgdata/msg.narc} con los mensajes o textos del juego, \textit{itemtool/itemdata/item\_icon.narc} con las imágenes de los objetos o \textit{graphic/font.narc} con las tipografías del juego.

\includefigure{fig:tr-pearlfiles}%
{Sistema de ficheros en Pokémon Perla visto con Tinke}%
{imgs/TR-PearlFiles.png}

\subsubsection{Textos}
\label{sec:tr-pok-pearl-text}
Centrándose en textos del juego se comprueba que están cifrados.
Tras una búsqueda de las frases de diálogos iniciales sobre todo el archivo binario del juego no se encuentran resultados.
Se probó en las codificaciones más frecuentes de esta consola como son ASCII y UNICODE sin resultado.
Esto indica que bien el archivo que contiene los textos está comprimido o cifrado.

El siguiente procedimiento fue extraer la memoria RAM del juego justo en el momento de mostrar ese diálogo, pues debería estar almacenada esa frase para poder ser mostrada en pantalla.
Esto se puede realizar gracias al emulador DeSmuME mencionado en el capítulo~\ref{sec:requirements}.
Una vez extraído el archivo binario con la memoria RAM, mediante visores hexadecimales se buscó la frase que aparecía en pantalla usando las codificaciones estándar y sin obtener resultado de nuevo.
Dado que la frase ha de estar en la memoria RAM, el problema era por tanto que no estaba usando una codificación estándar.
Existen dos procedimientos básicos para realizar una búsqueda en estos casos.

El primero consiste en buscar el archivo con la tipografía del juego, pues la codificación será la misma que el orden con el que aparecen los caracteres en ella.
En la tabla~\ref{tab:tr-pearlfont} se especifica el formato usado en este juego para estos archivos.
% TODO: Crear plugin de Tinke para exportarla.
% TODO: Añadir imagen de la tipografía extraída.

\ctable[
    caption = Especificación de tipografías en Pokémon Perla,
    label   = tab:tr-pearlfont,
    pos     = h
]{ccl}{
    \tnote[a]{Los caracteres están codificados por \textit{tiles} de 8x8 píxeles en formato horizontal.}
    \tnote[b]{Cada byte indica el ancho del caracter.}
}{                                                                      \FL
    Posición      & Tamaño        & Descripción                         \ML
    \multicolumn{3}{c}{Cabecera}                                        \NN
    \textsf{0x00} & \textsf{0x04} & Puntero a la sección de datos       \NN
    \textsf{0x04} & \textsf{0x04} & Puntero a la sección \acs{VWT}      \NN
    \textsf{0x08} & \textsf{0x04} & Número de caracteres                \NN
    \textsf{0x0C} & \textsf{0x01} & Ancho de un caracter                \NN
    \textsf{0x0D} & \textsf{0x01} & Alto de un caracter                 \NN
    \textsf{0x0E} & \textsf{0x01} & BPP                                 \NN
    \textsf{0x0F} & \textsf{0x01} & BPP                                 \ML
    \multicolumn{3}{c}{Datos de la fuente\tmark[a]}                     \ML
    \multicolumn{3}{c}{\ac{VWT}\tmark[b]}                               \LL
}

El segundo procedimiento posible es el de desarrollar un programa de búsqueda diferencial.
Con motivo de este trabajo en el capítulo~\ref{sec:requirements} se explica el programa \textit{RelativeSearch} que se llevó a cabo.
Este tipo de \textit{software} se puede usar siempre y cuando el orden de los caracteres de un mismo grupo (por ejemplo letras minúsculas) corresponda a estándares como ASCII.
Si se hubiese seguido un orden aleatorio en la codificación propietaria este no serviría quedando la primera opción como única alternativa.

Tras usar cualquiera de los dos procedimientos anteriormente descritos, se puedo encontrar una coincidencia en la memoria RAM del diálogo.
El siguiente paso consistió en depurar el juego para hallar el algoritmo de descifrado o descomprensión de textos.
Para ello usando los programas descritos en el capítulo~\ref{sec:requirements} de depuración, se puso un punto de interrupción en dicha posición.

Cabe destacar que esta posición es dinámica por lo que cambia cada vez que se inicia el juego pues depende de muchas variables.
Para sortear este problema se hizo uso de los \textit{savestates} del emulador, es decir guardados de memoria del juego que permiten ir a cualquier momento de una ejecución.
Gracias a esta característica se puede realizar un guardado justo antes de que el juego guarde un juego de forma que siempre que se use ese \textit{savestate} encontraremos el texto en la misma posición.
El punto de interrupción hizo parar el emulador justo en las instrucciones máquinas que estaban realizando, en este caso, el descifrado. Este algoritmo se describe a continuación.

El texto se encuentra cifrado usando la operación XOR y mediante una clave que se actualiza después de descifrar cada byte.
La clave inicial es igual a \verb!clave = (ushort)(0x91BD3 * (i + 1))! donde \verb!i! es el bloque de texto a descifrar.
Después de aplicar la clave sobre un byte esta se actualiza según \verb!clave = (ushort)(clave + 0x493D)!.

El cifrado no es exclusivo del texto pues la tabla de contenido con las posiciones y tamaños de cada diálogo se encuentra cifrado también.
La clave no coincide con la del texto y se forma de la siguiente manera: \verb!clave = (ushort)(clave_base * 0x2FD * (i + 1))!.
En este caso, se hace uso de una clave base que se encuentra disponible en la cabecera del fichero y de nuevo con número de entrada a descifrar (\verb!i!).
Dado que el tamaño de estos campos cifrados es de 32 bits y la clave de 16 bits, se concatena la clave dos veces formando el valor de 32 bits necesario para aplicar la operación XOR.

Sin embargo, esta parte del fichero a pesar de estar cifrado presenta un fallo de seguridad.
Como se ha comentado los valores cifrados de posición y tamaño son de 32 bits (4 bytes) pero en la mayoría de los casos solo se usan los dos primeros bytes pues tamaño del fichero de texto no supera los \verb!2^16 = 65535 bytes!.
Debido a la concateniación de la clave y a que los dos últimos bytes son 0, al cifrar estos dos bytes se estuvo guardando la clave en texto plano.
Es decir, se demuestra que \verb!a XOR 0 = a! siendo en este caso \verb!a! la clave para cifrar estas entradas y el valor guardado en el fichero en la mayoría de los casos.

En la tabla~\ref{tab:tr-pearltxt} se especifica el formato de los archivos de texto.

\ctable[
    mincapwidth = 110 mm,
    footerwidth,
    caption = Especificación del formato de texto en Pokémon Perla,
    label   = tab:tr-pearltxt,
    pos     = h,
]{ccl}{
    \tnote[a]{Se especifica solo la primera entrada.}
    \tnote[b]{Campo cifrado descrito en la sección~\ref{sec:tr-pok-pearl-text}.}
}{                                                                      \FL
    Posición      & Tamaño        & Descripción                         \ML
    \multicolumn{3}{c}{Cabecera}                                        \NN
    \textsf{0x00} & \textsf{0x02} & Número de bloques de texto          \NN
    \textsf{0x02} & \textsf{0x02} & Clave base para descifrar \acs{TOC} \ML
    \multicolumn{3}{c}{\acl{TOC}\tmark[a]}                               \NN
    \textsf{0x00} & \textsf{0x04} & Posición del texto\tmark[b]         \NN
    \textsf{0x04} & \textsf{0x08} & Tamaño del texto\tmark[b]           \ML
    \multicolumn{3}{c}{Texto\tmark[b]}                                  \LL
}

\subsubsection{Imágenes}
