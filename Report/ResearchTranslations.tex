% Copyright (c) 2015 Benito Palacios Sánchez - All Rights Reserved.
% Esta obra está licenciada bajo la Licencia Creative Commons Atribución 4.0
% Internacional. Para ver una copia de esta licencia, visita
% http://creativecommons.org/licenses/by/4.0/.

\chapter{Traducciones no oficiales y mods}
\label{sec:translations}

% TODO: Introducción de traducciones no oficiales y mods

\section{Saga Pokémon en \acl{NDS}}

% TODO: Introducción de Pokémon
% Fama de juegos -> seguidores -> reconocimiento personal y de una web.
% Tienen fijada fecha de localización a otros países desde que salen.
% Se cifra textos e imágenes para traducciones y mods
% Sonidos no cifrados, no hay interés

Los textos que aparecen en diálogos y menús, al igual que aquellos nombres para denominar a \textit{Pokémons} y ataques son el primer objetivo a la hora de realizar una traducción.

\subsection{Pokémon Perla y Diamante}
El par de juegos \textit{Pokémon Diamante y Perla} corresponden a la cuarta generación de saga y a la primera que salió para \acl{NDS}.
El primer país en recibirlos fue Japón a finales de septiembre de 2006 y como es frecuente mucho después llegó al resto del mundo.
Concretamente pasaron siete meses hasta la llegada a Estados Unidos y tres meses más hasta la llegada a Europa.

\subsubsection{Archivos}
Se trata del primera generación de juegos que llegan a esta consola donde como característica importante respecto a su antecesora (\acl{GBA}) es la introducción del sistema de ficheros.
En estos tres juegos, los archivos dentro del juego tienen nombres explicativos sobre su contenido (figura~\ref{fig:tr-pearlfiles}).
Ejemplo son ficheros como \textit{msgdata/msg.narc} con los mensajes o textos del juego, \textit{itemtool/itemdata/item\_icon.narc} con las imágenes de los objetos o \textit{graphic/font.narc} con las tipografías del juego.

\includefigure{fig:tr-pearlfiles}%
{Sistema de ficheros en Pokémon Perla visto con Tinke}%
{imgs/TR-PearlFiles.png}

\subsubsection{Textos}
\label{sec:tr-pok-pearl-text}
Centrándose en textos del juego se comprueba que están cifrados.
Tras una búsqueda de las frases de diálogos iniciales sobre todo el archivo binario del juego no se encuentran resultados.
Se probó en las codificaciones más frecuentes de esta consola como son ASCII y UNICODE sin resultado.
Esto indica que bien el archivo que contiene los textos está comprimido o cifrado.

El siguiente procedimiento fue extraer la memoria RAM del juego justo en el momento de mostrar ese diálogo, pues debería estar almacenada esa frase para poder ser mostrada en pantalla.
Esto se puede realizar gracias al emulador DeSmuME mencionado en el capítulo~\ref{sec:requirements}.
Una vez extraído el archivo binario con la memoria RAM, mediante visores hexadecimales se buscó la frase que aparecía en pantalla usando las codificaciones estándar y sin obtener resultado de nuevo.
Dado que la frase ha de estar en la memoria RAM, el problema era por tanto que no estaba usando una codificación estándar.
Existen dos procedimientos básicos para realizar una búsqueda en estos casos.

El primero consiste en buscar el archivo con la tipografía del juego, pues la codificación será la misma que el orden con el que aparecen los caracteres en ella.
En la tabla~\ref{tab:tr-pearlfont} se especifica el formato usado en este juego para estos archivos.
% TODO: Crear plugin de Tinke para exportarla.
% TODO: Añadir imagen de la tipografía extraída.

\ctable[
    caption = Especificación de tipografías en Pokémon Perla,
    label   = tab:tr-pearlfont,
    pos     = h
]{ccl}{
    \tnote[a]{Los caracteres están codificados por \textit{tiles} de 8x8 píxeles en formato horizontal.}
    \tnote[b]{Cada byte indica el ancho del caracter.}
}{                                                                      \FL
    Posición      & Tamaño        & Descripción                         \ML
    \multicolumn{3}{c}{Cabecera}                                        \NN
    \textsf{0x00} & \textsf{0x04} & Puntero a la sección de datos       \NN
    \textsf{0x04} & \textsf{0x04} & Puntero a la sección \acs{VWT}      \NN
    \textsf{0x08} & \textsf{0x04} & Número de caracteres                \NN
    \textsf{0x0C} & \textsf{0x01} & Ancho de un caracter                \NN
    \textsf{0x0D} & \textsf{0x01} & Alto de un caracter                 \NN
    \textsf{0x0E} & \textsf{0x01} & BPP                                 \NN
    \textsf{0x0F} & \textsf{0x01} & BPP                                 \ML
    \multicolumn{3}{c}{Datos de la fuente\tmark[a]}                     \ML
    \multicolumn{3}{c}{\ac{VWT}\tmark[b]}                               \LL
}

El segundo procedimiento posible es el de desarrollar un programa de búsqueda diferencial.
Con motivo de este trabajo en el capítulo~\ref{sec:requirements} se explica el programa \textit{RelativeSearch} que se llevó a cabo.
Este tipo de \textit{software} se puede usar siempre y cuando el orden de los caracteres de un mismo grupo (por ejemplo letras minúsculas) corresponda a estándares como ASCII.
Si se hubiese seguido un orden aleatorio en la codificación propietaria este no serviría quedando la primera opción como única alternativa.

Tras usar cualquiera de los dos procedimientos anteriormente descritos, se puedo encontrar una coincidencia en la memoria RAM del diálogo.
El siguiente paso consistió en depurar el juego para hallar el algoritmo de descifrado o descomprensión de textos.
Para ello usando los programas descritos en el capítulo~\ref{sec:requirements} de depuración, se puso un punto de interrupción en dicha posición.

Cabe destacar que esta posición es dinámica por lo que cambia cada vez que se inicia el juego pues depende de muchas variables.
Para sortear este problema se hizo uso de los \textit{savestates} del emulador, es decir guardados de memoria del juego que permiten ir a cualquier momento de una ejecución.
Gracias a esta característica se puede realizar un guardado justo antes de que el juego guarde un juego de forma que siempre que se use ese \textit{savestate} encontraremos el texto en la misma posición.
El punto de interrupción hizo parar el emulador justo en las instrucciones máquinas que estaban realizando, en este caso, el descifrado. Este algoritmo se describe a continuación.

El texto se encuentra cifrado usando la operación XOR y mediante una clave que se actualiza después de descifrar cada byte\footnote{Al no ser una clave constante no se puede obtener esta al ser aplicada sobre zonas con valores a 0 como sí sucede en el caso de la tabla de contenido.}.
La clave inicial es igual a \verb!clave = (ushort)(0x91BD3 * (i + 1))! donde \verb!i! es el bloque de texto a descifrar.
Después de aplicar la clave sobre un byte esta se actualiza según \verb!clave = (ushort)(clave + 0x493D)!.

El cifrado no es exclusivo del texto pues la tabla de contenido con las posiciones y tamaños de cada diálogo se encuentra cifrado también.
La clave no coincide con la del texto y se forma de la siguiente manera: \verb!clave = (ushort)(clave_base * 0x2FD * (i + 1))!.
En este caso, se hace uso de una clave base que se encuentra disponible en la cabecera del fichero y de nuevo con número de entrada a descifrar (\verb!i!).
Dado que el tamaño de estos campos cifrados es de 32 bits y la clave de 16 bits, se concatena la clave dos veces formando el valor de 32 bits necesario para aplicar la operación XOR.

Sin embargo, esta parte del fichero a pesar de estar cifrado presenta un fallo de seguridad.
Como se ha comentado los valores cifrados de posición y tamaño son de 32 bits (4 bytes) pero en la mayoría de los casos solo se usan los dos primeros bytes pues tamaño del fichero de texto no supera los \verb!2^16 = 65535 bytes!.
Debido a la concateniación de la clave y a que los dos últimos bytes son 0, al cifrar estos dos bytes se estuvo guardando la clave en texto plano.
Es decir, se demuestra que \verb!a XOR 0 = a! siendo en este caso \verb!a! la clave para cifrar estas entradas y el valor guardado en el fichero en la mayoría de los casos.

En la tabla~\ref{tab:tr-pearltxt} se especifica el formato de los archivos de texto.

\ctable[
    mincapwidth = 110 mm,
    footerwidth,
    caption = Especificación del formato de texto en Pokémon Perla,
    label   = tab:tr-pearltxt,
    pos     = h,
]{ccl}{
    \tnote[a]{Se especifica solo la primera entrada.}
    \tnote[b]{Campo cifrado descrito en la sección~\ref{sec:tr-pok-pearl-text}.}
}{                                                                      \FL
    Posición      & Tamaño        & Descripción                         \ML
    \multicolumn{3}{c}{Cabecera}                                        \NN
    \textsf{0x00} & \textsf{0x02} & Número de bloques de texto          \NN
    \textsf{0x02} & \textsf{0x02} & Clave base para descifrar \acs{TOC} \ML
    \multicolumn{3}{c}{\acl{TOC}\tmark[a]}                              \NN
    \textsf{0x00} & \textsf{0x04} & Posición del texto\tmark[b]         \NN
    \textsf{0x04} & \textsf{0x08} & Tamaño del texto\tmark[b]           \ML
    \multicolumn{3}{c}{Texto\tmark[b]}                                  \LL
}

\subsubsection{Imágenes}
\label{sec:tr-pok-pearl-img}
En el caso de la saga de Pokémon las imágenes no contienen frases con texto por lo que en cuanto a una traducción respecta no son necesarias editarlas.
Sin embargo, dada la popularidad de los \textit{mods} y de la extracción de imágenes en estos juegos se apostó por cifrar un tipo concreto de las mismas.
Se trata de los \textit{sprites} de los \textit{Pokémons} que aparecen durante las batallas.
Estos archivos están contenidos en el paquete \textit{poketool/pokegra/pokegra.narc} donde hay seis imágenes por monstruo.

El cifrado se realizó sobre los datos de la imagen, manteniendo las cabeceras del formato de la misma sin cifrar.
Como consecuencia, las imágenes se podían abrir usando programas estándares pero sin ver nada en concreto.
% TODO: Hacer programa y descifrar una imagen y poner comparativa

El procedimiento para encontrar el algoritmo de cifrado en este caso es distinto al realizado con texto.
No se puede partir de datos conocidos como anteriormente se partía de una frase que se veía en la pantalla.
Sin embargo, dado que las cabeceras de la imagen no están cifradas se pudo buscar sobre el código en ensamblador la función que procesa esta cabecera.
En concreto se buscó la palabra mágica \textsf{CHAR} que se procesaa para determinar el comienzo de una sección del archivo.

Una vez encontrado la función que lee una imagen, solo habría que acceder a una parte del juego donde se esperaba que se cargase una imagen como durante una batalla y poner un punto de interrupción sobre esta función.
Tras omitir imágenes que no estaban cifradas\footnote{Dado que una imagen contiene suele tener píxeles cercanos de igual colores, siempre que en los datos se observara patrones se podía determinar que no estaba cifrada.}, se llegó a una que sí lo estaba donde se puso un punto de interrupción.

La siguiente función que leía los datos de dicha imagen era el algoritmo de descifrado. Este algoritmo parte del hecho que todo el bloque de datos de una imagen tendrá el tamaño constante de \textsf{0x1900} bytes.
Se trata de un cifrado parecido al realizado sobre el texto donde habrá una clave que irá cambiando después de aplicarse sobre cada valor y que se usará para aplicar la operación XOR sobre un dato cifrado.
En este caso, la clave es de 32 bits y el dato a descifrar de 16 bits y se comencerá desde el final del fichero hasta el principio.
La clave inicial será el primer valor (últimos dos bytes del fichero) e irá cambiando siguiendo la siguiente operación \verb!clave = (uint)(clave * 0x41C64E6D + 0x6073)!.

\subsubsection{Conclusión}

\begin{tabular}{p{0.4\textwidth}p{0.5\textwidth}}
Pros & Contras \\
% Pros
\begin{itemize}
\item Los textos usando una codificación no estándar.
\item Los textos están cifrados con una clave no estática.
\item Las imágenes están cifradas con un clave no estática.
\end{itemize} &

% Contras
\begin{itemize}
\item Los archivos y carpetas tienen nombres descriptivos.
\item Hay un fallo de seguridad en el cifrado de la tabla de contenido de los textos por el que se puede averiguar la clave.
\end{itemize} \\
\end{tabular}

\underline{Propuesta:} Desordenar los caracteres en la fuente para que no se pueda realizar una búsqueda diferencial.
Cifrar la fuente también pues es uno de los puntos principales de entrada a la hora de investigar el cifrado.
No utilizar formatos estándares en las imágenes a pesar de cifrarlas, ya que es más complicado hacer un \textit{software} que trate con imágenes que descifre.


\subsection{Pokémon HeartGold y SoulSilver}
Los juegos \textit{Pokémon HeartGold y SoulSilver} son las siguiente generación de la saga que salieron también para \acl{NDS}.
Se repite como es común el orden y plazo de lanzamiento. De esta forma se lanzó primero en Japón a mediados de septiembre de 2009, a continuación en América seis meses después, en abril de 2010, y finalmente en Europa una semana después.
Esta vez no hubo mucha diferencia entre los lanzamientos de América y Europa lo que provocaría que no fuese necesario realizar traducciones no oficiales desde el inglés, idioma desde el cual al ser más sencillo se parten la mayoría de las traducciones.

% TODO: Añadir bibliografía con las URL a los proyectos de traducción:
% PP: http://projectpokemon.org/forums/showthread.php?4534-Pokemon-HeartGold-and-SoulSilver-Translation-Patch
% GBATEMP: https://gbatemp.net/threads/magniuss-pokemon-soul-silver-translation.179686

\subsubsection{Archivos}
\label{sec:tr-pok-heart-file}
La primera gran diferencia en esta generación llega con el ofuscado de nombres de archivos y directorios. Como se puede apreciar en la figura~\ref{fig:tr-heartfiles} todos los archivos principales del juego están nombrados con números y clasificados en carpetas númericas también.
Además, el contenido de estas carpetas no relaciona a los archivos entre sí generando una organización aleatoria.
En total hay 275 archivos que a su vez son contenedores de subarchivos sin nombre.
Estos contenedores pueden llegar a tener más de 1000 archivos en su interior pero si se garantiza que el contenido de estos está relacionado entre si correspondiendo a las imágenes a las características de \textit{Pokémon} o las imágenes de un menú concreto.

\includefigure{fig:tr-heartfiles}%
{Carpetas y ficheros ofuscados en Pokémon HeartGold}%
{imgs/TR-HeartFiles.png}

Mediante depuración del código ensamblador se pudo comprobar la implementación del acceso a estos archivos.
Todo se realiza llamando a varias funciones de similar cometido cuyo primer parámetro es un ID que identifica al archivo y como segundo parámetro el sub-archivos dentro del contenedor.
Este ID es lineal y si se descompone en base diez se puede calcular la ruta absoluta.
De esta forma el ID \textsf{0x1B} (27) corresponde a \verb!27 = 0*10 + 2*10 + 7! lo que significa que estaría ubicado en \textit{a/0/2/7}.
A la hora de implementar este mecanismo durante el desarrollo del videojuego se usuaría un archivo de cabeceras similar al siguiente.

\begin{verbatim}
file_paths.h
#define MESSAGE_FILE_ID 0x1B
#define POKEMON_IMAGES_FILE_ID 0x1C
\end{verbatim}

De esta manera, en el proceso de desarrollo sería fácil y sin ofuscar su propio código el indicar qué fichero cargar usando las constantes definidas.
Este método es sencillo de implementar y dificulta la tarea de edición del juego pues entre los 275 archivos disponibles, binarios, sin estructuras de datos conocidas, habría que averiguar qué hace cada uno sin tener una pista previa como pasaba en ediciones anteriores donde el nombre era descriptivo del contenido.

\subsubsection{Textos}
Los textos de esta generación vienen igualmente cifrados.
Esto se pudo comprobar al realizar de nuevo una búsqueda de palabras de los primeros diálogos y no tener resultados ni en el archivo binario del juego ni sobre la memoria RAM.

Tras repetir el proceso descrito en la sección~\ref{sec:tr-pok-pearl-text} de textos de la generación anterior, se comprobó que tanto el formato del archivo como el algoritmo de cifrado y claves son exactamente las mismas a las descritas ahí. Además el formato de las fuentes es también el mismo.

En esta nueva generación no se apostó por cambiar el cifrado de textos y delegar toda la responsabilidad de dificultar la tarea de edición en el ofuscamiento de nombres de ficheros. El fichero está localizado en \textit{a/0/2/7}.

\subsubsection{Imágenes}
Al igual que sucede con los textos, tras repetir los pasos de la sección~\ref{sec:tr-pok-pearl-img} de imágenes se descubrió que se utiliza el mismo algoritmo de cifrado con las mismas claves. Se encontró sin embargo, una diferencia en la implementanción pues en este caso se descifra empezando por el comienzo de los datos en lugar de por el final.

\subsubsection{Conclusión}

\begin{tabular}{p{0.4\textwidth}p{0.5\textwidth}}
Pros & Contras \\
% Pros
\begin{itemize}
\item Los archivos están ofucados por nombre y directorio.
\end{itemize} &

% Contras
\begin{itemize}
\item No todos los archivos están ofuscados como se ve en la siguiente apartado.
\item Se mantiene los mismos algoritmos y claves que en la generación anterior por lo que una vez encontrado los archivos se pueden reutilizar las mismas herramientas.
\end{itemize} \\
\end{tabular}

\underline{Propuesta:} Cambiar las claves y el tipo de cifrado para que no se pueda reutilizar los de la generación anterior y sea necesario una investigación.


\subsection{Pokémon Blanco y Negro}

% TODO: Añadir bibliografía con las URL a los proyectos de traducción:
% PP: http://projectpokemon.org/forums/showthread.php?11397-Pokemon-Black-and-White-Translation-Project
% PP: http://projectpokemon.org/forums/showthread.php?11438-Pokmon-Blanco-y-Negro-Traduccin
% PP: http://projectpokemon.org/forums/showthread.php?11746-Pok%E9mon-Black-and-White-Translation-Project-v3-%28Project-is-complete!%29

\subsubsection{Archivos}
En la sexta generación decidieron optar de nuevo por ofuscar los nombres de las carpetas y archivos.
En este caso, se dio un paso más y se hizo sobre todos los archivos.
Sin bien, en el caso de \textit{Pokémon HeartGold y SoulSilver} fueron solo los archivos principales los ofuscados, en esta edición los únicos que no se procesaron fueron los de sonido y demo como se aprecia en la figura~\ref{fig:tr-blackheartfiles}.

\includefigure{fig:tr-blackheartfiles}%
{Comparación de carpetas entre Pokémon Blanco (izq.) y Pokémon HeartGold (der.)}
{imgs/TR-BlackHeartFiles.png}

A pesar de usar internamente la misma forma de acceso a como se describió en el apartado de archivos de la sección~\ref{sec:tr-pok-heart-file}, los identificadores y por tanto localización de estos cambió.
Pasando de esta forma el archivo con los textos del juego a estar en \textit{a/0/0/2} en lugar de \textit{a/0/2/7} como sucedía en la edición anterior.

\subsubsection{Textos}
\label{sec:tr-pok-black-text}
En el apartado de protección a los textos, en las dos generaciones anteriores se utilizó un mismo algoritmo basado en un clave dinámica que se aplicaba con la operación XOR.
En esta generación la filosofía del algoritmo se mantiene cambiando no obstante la forma de generación y actualización de la clave.
Esta se pudo obtener tras realizar el procedimiento descrito en el apartado textos de la sección~\ref{sec:tr-pok-pearl-text}.

La principal diferencia tras aplicar el método de investigación de cifrado fue ver que no se usaba una codificación propia si no UTF-16.
Esto facilitó la tarea, pues ya no es necesaria una búsqueda diferencial en la memoria RAM y por tanto crear \textit{software} adicional para investigar.
Se trata por tanto de la eliminación de un mecanismo fuerte a la hora de proteger datos que posiblemente estaba realizando en ediciones anteriores de casualidad.

La clave inicial usada para el texto se genera usando el número de bloque como variable, de forma que cada bloque comienza con una clave diferente. La operación es \verb!clave = (i + 3) * 0x2983!.
Tras aplicar esta clave sobre un valor de 16 bits cifrado (dos bytes), se actualiza desplazando los tres bits más significados a la posición menos significativa.
Esto se puede conseguir aplicando la siguiente serie de operaciones.

\begin{verbatim}
temp  = clave & 0x1FFF;             // Elimina los bits más significativos
clave = (temp << 3) | (clave >> 13) // y los añade al principio.
\end{verbatim}

Al desplazarse un número impar de veces, cada bit pasará de forma lineal sobre cada posición de la clave obteniéndose el máximo de permutaciones para una clave de 16 bits, es decir se usará a la hora de cifrar y descifrar 16 claves diferentes.

La estructura de datos se especifica en la tabla~\ref{tab:tr-blacktxt} donde se puede ver que la sección con la tabla de contenido no está cifrada a diferencia de cómo pasaba en ediciones anteriores.

\ctable[
    mincapwidth = 110 mm,
    footerwidth,
    caption = Especificación del formato de texto en Pokémon Blanco,
    label   = tab:tr-blacktxt,
    pos     = h,
]{ccl}{
    \tnote[a]{Se especifica solo la primera entrada.}
    \tnote[b]{Cada caracter es un valor de 16 bits.}
    \tnote[c]{Campo cifrado descrito en la sección~\ref{sec:tr-pok-black-text}.}
}{                                                                          \FL
    Posición      & Tamaño        & Descripción                             \ML
    \multicolumn{3}{c}{Cabecera}                                            \NN
    \textsf{0x00} & \textsf{0x02} & Constante: \textsf{0x01}                \NN
    \textsf{0x02} & \textsf{0x02} & Número de bloques de texto              \NN
    \textsf{0x04} & \textsf{0x04} & Tamaño de la sección de datos           \NN
    \textsf{0x08} & \textsf{0x04} & Constante: \textsf{0x00}                \NN
    \textsf{0x0C} & \textsf{0x04} & Tamaño de la cabecera                   \ML
    \multicolumn{3}{c}{Datos}                                         \NN
    \textsf{0x00} & \textsf{0x04} & Tamaño de la sección                    \NN
    \textsf{0x04} & \textsf{0x04} & Posición relativa a la sección\tmark[a] \NN
    \textsf{0x06} & \textsf{0x02} & Número de caracteres\tmark[a]\tmark[b]  \NN
    \textsf{0x08} & \textsf{0x02} & Desconocido\tmark[a]                    \ML
    \multicolumn{3}{c}{Texto\tmark[c]}                                      \LL
}

\subsubsection{Imágenes}
Las imágenes a diferencia de las pasadas generaciones no se cifraron.
En cambio, no se utiliza un formato estándar de codificación.
Si bien el formato para las paletas y datos de imagen si se reutiliza y sigue siendo estándar, existe un ficheros extras con una especificación nueva en este juego con la información necesaria para recomponer la imagen (figura~\ref{fig:tr-blackimg}).

\includefigure{fig:tr-blackimg}%
{Imágenes sin cifrar en Pokémon Negro.}%
{imgs/TR-BlackImg.png}

Esta forma de codificación, aunque pudiendo no ser específica para protegerlas ante modificaciones si no un requisito para animaciones, es más fuerte.
De esta forma los programas de ediciones genéricas creados para juegos de \acl{NDS} ya no son útiles y se necesita nuevos y específicos.
Esta tarea requiere de investigación de formatos y de programación, algo que toma más esfuerzo y tiempo que crear un decodificador como pasaba en las generaciones anteriores.

A pesar de ello, esta reconstrucción y edición de la imagen se podría llegar a cabo manualmente ya que el formato de los ficheros principales: paleta y datos de imagen, sigue siendo el estándar para juegos de la \acl{NDS}.

\subsubsection{Conclusión}

\begin{tabular}{p{0.4\textwidth}p{0.5\textwidth}}
Pros & Contras \\
% Pros
\begin{itemize}
\item Los nombres de las carpetas y archivos están ofuscados.
\item Los textos están cifrados con un nuevo algoritmo y clave.
\item Las imágenes usan archivos extras con especificaciones nuevas para recomponerlas por lo que \textit{software} nuevo sería necesario.
\end{itemize} &

% Contras
\begin{itemize}
\item Los textos no usan una codificación propia.
\item Las imágenes no está cifradas.
\item Las imágenes usando el formato estándar para los archivos principales.
\end{itemize} \\
\end{tabular}

\underline{Propuesta:} Usar una codificación propia, de 16 bits, en lugar de una estándar pues dificulta la búsqueda del algoritmo de cifrado.
Al igual que en la propuesta de generaciones anteriores, desordenar los caracteres en la codificación.
Cifrar las imágenes es un buen mecanismo ya que requiere \textit{software} y trabajo adicional.
Además, cambiando el formato de todas las imágenes haría que programas genéricos no fueran útiles.

\subsection{Pokémon Conquest}

% TODO: Añadir bibliografía con las URL a los proyectos de traducción:
% PC: http://pokecheats.net/forum/showthread.php?13925-Translation-project-for-Pok%C3%A9mon-Nobunaga-s-Ambition&s=722c3c7d8b0c4df38ba6b023bc4fe633

\subsubsection{Archivos}
En este juego no se han ofuscado los archivos y carpetas.
Todo está bien organizado y con nombres descriptivos.

\subsubsection{Textos}
\label{sec:tr-pok-conquest-text}
Los textos sí han cifrado y codificado con una protección mayor que en otras generaciones.
Para encontrar se buscó en primer lugar sobre la memoria RAM repitiendo el proceso explicado en el apartado textos de la sección~\ref{sec:tr-pok-pearl-text}.
Dado que se usa la codificación estándar SJIS se pudo encontrar directamente.

Una vez puesto el punto de interrupción se dio con el algoritmo que descodifica estos caracteres.
Con el objetivo de ahorra espacio y ofuscar el texto los archivos de textos tienen una codificación especial basada en caracteres de control y optimizada para caracteres japoneses.
Su sistema se basa en especificar solo un byte por caracter japonés en lugar de dos como dice SJIS.
El segundo caracter restante al estar comprendido entre \textsf{0x81-0x83} y es igual entre caracteres cercanos, se va predice mediante unos códigos de control.
Esta codificación está implementada en ambos sentidos en el proyecto AmbitionText\footnote{\url{http://subirelcodigo}}.
Destaca esta codificación pues no es sencilla de implementar y requiere mucho esfuerzo de creación de una herramienta que permita trabajar con ella.

Antes de esta parte de codificación, el texto se descifra.
El cifrado se basa en aplicar la clave ``\textsf{MsgLinker Ver1.00}'' sobre cada byte de texto.
A continuación se muestra la implementación en C\# para el cifrado y descifrado\footnote{\url{http://subirelcodigo}}.
El formato del fichero se especifica en la tabla~\ref{tab:tr-conquesttxt}.

\begin{verbatim}
string key = "MsgLinker Ver1.00";
for (int i = 0; i < data.Length; i++)
    data[i] ^= key[i % key.Length];
\end{verbatim}

\ctable[
    caption = Especificación del formato de texto en Pokémon Conquest,
    label   = tab:tr-conquesttxt,
    pos     = h,
]{ccl}{
    \tnote[a]{Se especifica solo la primera entrada.}
    \tnote[b]{Existen 33 bloques.}
    \tnote[c]{Campo cifrado descrito en la sección~\ref{sec:tr-pok-conquest-text}.}
}{                                                                          \FL
    Posición      & Tamaño        & Descripción                             \ML
    \multicolumn{3}{c}{\acl{TOC}\tmark[a]\tmark[b]}                         \NN
    \textsf{0x00} & \textsf{0x04} & Posición del bloque                     \NN
    \textsf{0x04} & \textsf{0x04} & Tamaño del bloque                       \ML
    \multicolumn{3}{c}{Bloques\tmark[c]}                                    \LL
}

\subsubsection{Imágenes}
Tanto los fondos como los \textit{sprites} del juego no vienen cifrados.
Sin embargo se usan formatos de ficheros nuevos, con codificaciones nuevas que supusieron un trabajo extra de creación de \textit{software}\footnote{\url{https://github.com/pleonex/tinke/tree/master/Plugins/PSL}}.

\subsubsection{Conclusión}

\begin{tabular}{p{0.4\textwidth}p{0.5\textwidth}}
Pros & Contras \\
% Pros
\begin{itemize}
    \item Los textos vienen cifrados y codificados.
    \item La codificación es única para este juego.
    \item Nuevos formatos de imágenes que requieren nuevos programas.
\end{itemize} &

% Contras
\begin{itemize}
    \item Los archivos y carpetas no están ofuscados.
    \item Se usa una codificación final estándar.
    \item Las imágenes no están cifradas.
\end{itemize} \\
\end{tabular}

\underline{Propuesta:} En general los mecanismos de protección son lo suficiente fuertes.
Faltaría respecto a la otra línea de juegos ofuscar archivos y carpetas y cifrar imágenes y usar una codificación final no estándar.
Además a este respecto habría que cifrar la fuente y desordenar los caracteres.

\section{Ninokuni y el Mago de las Tinieblas}

% TODO: Intro

\subsubsection{Archivos}
Los archivos y carpetas no están ofuscadas y está todo bien organizado y clasificado.

\subsubsection{Textos}
En cuanto al apartado de textos hay que distiguir de dos tipos: \textit{scripts} y nombres y descripciones.
Empezando por el último, este tipo de textos se encuentran en archivos que contienen las características de personajes, objetos y ataques y no solo el texto.
Con el objetivo de editar los parámetros que definen sus características y hacer una versión modificada del mismo con mayor, menor o una jugabilidad distinta estos ficheros se cifraron.
El cifrado es muy básico y pero eficaz ante personas que no entienden.
En la figura~\ref{fig:tr-nino-minitext} se puede ver como se repite el byte \textsf{0xFF} con frecuencia.
Esto da una pista del tipo de cifrado empleado pues probando a realizar una operación \textsf{XOR 0xFF} o lo que es lo mismo \textsf{NOT} se puede ver como todo queda descifrado.

\includefigure{fig:tr-nino-minitext}%
{Archivo cifrado (arr.) y descifrado (ab.) de Ninokuni y el Mago de las Tinieblas}%
{imgs/TR-NinoMiniText.png}

Respecto a los \textit{scripts} debido a sus requisitos técnicos para ejecutar todo tipo de comandos son complejos de investigar.
A día de hoy solo existe un \textit{software} no público desarrollado para la traducción al español que solo es capaz de editar los textos de los diálogos.
El formato está basado en parámetros a nivel de bits lo que hace inviable investigar el formato sin mirar las instrucciones máquinas del juego que lo procesan.

\subsubsection{Imágenes}
Las imágenes no están cifradas pero los archivos asociados a una imagen están comprimidos en un nuevo formato.
Son fáciles de extraer pero requiere nuevo \textit{software}\footnote{\url{https://github.com/pleonex/ninoimager}}.

\subsubsection{Conclusión}

\begin{tabular}{p{0.4\textwidth}p{0.5\textwidth}}
Pros & Contras \\
% Pros
\begin{itemize}
    \item Formato complejo en los \textit{scripts}.
    \item Cifrado básico en algunos archivos de texto.
\end{itemize} &

% Contras
\begin{itemize}
    \item En general no están cifrado los archivos de texto.
    \item Las imágenes no están cifradas.

\end{itemize} \\
\end{tabular}

\underline{Propuestas:} Aplicar mecanismos de protección sobre textos e imágenes e utilizar una codificación de texto propia.

\section{Proyectos abandonados}
Para terminar se incluye un estudio sobre los proyectos de traducciones no oficiales que han sido abandonados con fecha de este trabajo y con sus respectivos motivos.
El estudio se ha centrado en juegos para la \acl{NDS} a partir de~\cite{GTemp-Aband} y~\cite{RH-Aband}.

El objetivo será el de mostrar las causas más frecuentes que como se verá en la mayoría de los casos fue por la confirmación de una localización al idioma de la traducción.

\subsubsection{Ausencia de \textit{software} de edición}
Surgidos por la falta de personal con conocimientos técnicos y de programación que puedan crear los programas necesarios de edición.
\begin{itemize}
\item WWII - Tank Battles (\acs{PS2}): Ausencia de descompresor de archivos.
\item Chi's Sweet Home: Chi ga Ouchi ni Yatte Kita! (\acs{NDS}): Ausencia de importador de imágenes.
\item Brave Fencer Musashi (\acs{PSX}): Ausencia de editor de textos.
\item Code Geass: Hangyaku no Lelouch (\acs{NDS}): Ausencia de editor de textos.
\item Custom Beat Battle Draglade 2 (\acs{NDS}): Ausencia de editor de textos.
\item Mobile Suit Gundam 00 (\acs{NDS}): Ausencia de editor de textos.
\item Super Robot Taisen OG Saga: Mugen No Frontier (\acs{NDS}): Ausencia de editor de textos.
\item Mysterious Dungeon: Shiren the Wanderer 2 (\acs{NDS}): Ausencia de editor de textos y de modificaciones técnicas necesarias sobre el juego.
\end{itemize}

\subsubsection{Problemas técnicos tras editar el juego}
Problemas surgidos durante la traducción que no se solucionaron debido a falta de conocimientos o abandono de soporte de quienes crearon las herramientas.
\begin{itemize}
\item Dai Kaijuu Monogatari (\acs{PSX}): Los programas usados para editar los textos causan bloqueos en el juego.
\item Resident Evil 2 (\acs{DC} y \acs{GC}): El compresor de archivos creado no funcionaba con todos.
\end{itemize}

\subsubsection{Abandono personal}
Causado en su mayoría por una falta de motivación y tiempo del equipo que lo llevaba a cabo.
\begin{itemize}
\item Professor Layton: London Life (\acs{NDS}).
\item Cross Treasures (\acs{NDS}).
\item Element Hunters (\acs{NDS}).
\item Hajime no Ippo The Fighting! DS (\acs{NDS}).
\item Naruto: Ninja Destiny 3 (\acs{NDS}).
\item Super Robot Wars K (\acs{NDS}).
\end{itemize}

\subsubsection{Traducción oficial}
Abandonos de proyectos por la llegada o confirmación de una traducción oficial.
\begin{itemize}
\item Final Fantasy: The 4 Warriors of Light (\acs{NDS}). Traducción inglesa.
\item Fire Emblem: Shadow Dragon (\acs{NDS}).
\item Glory of Heracles (\acs{NDS}).
\item Inazuma Eleven (\acs{NDS}).
\item Kindom Hearts 356/2 Days (\acs{NDS}).
\item Naruto: Ninja Destiny 2 (\acs{NDS}).
\item Nostalgia (\acs{NDS}).
\end{itemize}

Se puede ver que el problema más común está la falta de programas de edición de juegos concretos.
Para poder llevar a cabo esto hace falta unos conocimientos técnicos tanto de \textit{software} como de \textit{hardware} y de una larga experiencia.
Es por esto que a la hora de empezar un proyecto la parte técnica suele ser la más complicada de resolver y que en muchos casos nunca se llega a resolver del todo.

La segunda causa más frecuente es la confirmación de la llegada de una localización, suficiente motivo para parar el proyecto y no dañar los intereses de mercado de una empresa.
