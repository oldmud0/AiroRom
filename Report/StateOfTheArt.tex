% Copyright (c) 2015 Benito Palacios Sánchez - All Rights Reserved.
% Esta obra está licenciada bajo la Licencia Creative Commons Atribución 4.0
% Internacional. Para ver una copia de esta licencia, visita
% http://creativecommons.org/licenses/by/4.0/.

\chapter{Seguridad en videojuegos}
\label{sec:art}
Este trabajo explora los conceptos de seguridad y videojuegos.
Unos términos que en principio no se suelen relacionar, a no ser que se hable sobre la piratería, fenómeno que aumenta cada día más, esperando un crecimiento del 22\% para 2015~\cite{Arxan}.
Esta fuente menciona también la ingeniería inversa como `\textit{usando herramientas genéricas, los hackers pueden convertir rápidamente binarios desprotegidos en código fuente, volver a empaquetarlos y distribuirlos}'.

Comúnmente se asocia el término de \textit{hacker} a una persona que maliciosamente investiga un programa.
Es una mala interpretación dada por medios y películas, ya que realmente se habría de hablar de \textit{cracker}.
El nombre de \textit{hacker} nació en 1961, en los laboratorios del \ac{MIT}, para denominar a los estudiantes que dominaban con destreza la programación.
A día de hoy, según el RFC 1392\footnote{\url{https://tools.ietf.org/html/rfc1392}} se define \textit{hacker} como:

\foreignquote{english}{\textit{Hacker: A person who delights in having an intimate understanding of the internal workings of a system, computers and computer networks in particular. The term is often misused in a pejorative context, where `cracker' would be the correct term.}}

\foreignquote{spanish}{Hacker: Persona apasionada por entender cómo funciona internamente y en detalle, un conjunto de sistemas, ordenadores y redes de ordenadores. Generalmente se usa de forma incorrecta en un contexto peyorativo, debiendo usarse de modo más correcto `cracker'.}

De esta forma, este mismo RFC define \textit{cracker} como:

\foreignquote{english}{\textit{Cracker: A cracker is an individual who attempts to access computer systems without authorization. These individuals are often malicious, as opposed to hackers, and have many means at their disposal for breaking into a system.}}

\foreignquote{spanish}{Cracker: Individuo que intenta acceder a un sistema de ordenadores sin autorización. Estos individuos son generalmente maliciosos, en oposición a los `hackers', y tienen intereses ocultos en su intento por romper el sistema.}

Este trabajo muestra la seguridad de los juegos con el único propósito de enseñanza, como menciona Andew Huang~\cite[p.~7]{Xbox}: \textit{For every copyright protection scheme that is defeated by a hacker, there is someone who learned an important lesson about how to make a better protection scheme.} (\textit{Para cada esquema de protección con copyright que un hacker rompe, hay alguien que aprende una importante lección sobre cómo hacer un esquema de protección más robusto.}).

\section{Conceptos de seguridad}
\label{sec:art-sec}\label{sec:int-sec}
El concepto de seguridad se puede definir en tres puntos: la condición de un sistema como resultado del establecimiento y mantenimiento de medidas de protección; la condición de un sistema en el cual sus recursos están libres de accesos no autorizados y de cambios accidentales no autorizados, destrucción o, pérdida; medidas tomadas para proteger un sistema.\footnote{\url{https://tools.ietf.org/html/rfc4949}}.
Esta puede estar referida a tres ámbitos:

\begin{itemize}
    \item La seguridad de la información trata sobre la protección de datos guardados.
    \item La seguridad en las comunicaciones se refiere a la protección en la transmisión de datos
    \item La seguridad de sistemas se centra en la protección de entidades por los que pasa la información.
\end{itemize}

Este trabajo abarca los dos primeros puntos, habiendo una pequeña introducción sobre el tercero en el Apartado~\ref{sec:art-video} de seguridad en videconsolas.

Max Kilger, investigador de ciberseguridad, resume la motivación de las amenazas con las siglas \texttt{MEECES} del inglés dinero, ego, entretenimiento, ideología, entrada en grupos sociales y estatus social.

Con el objetivo de hacer frente a estas amenazas, existen varios modelos de seguridad con los aspectos que debe cumplir un sistema considerarse protegido.
El más conocido se denomina CIA, por las iniciales de los tres principales puntos recogidos a continuación.
A este modelo se añaden cuatro puntos más, resultando la siguiente lista:

\begin{itemize}
    \item Confidencialidad: la información solo puede estar accesible por los entes autorizados.
    \item Integridad: se ha de garantizar que la información no ha sido modificada de manera no autorizada.
    \item Disponibilidad (\textit{Availability}): la información ha de estar accesible cuando se solicita.
    \item Autenticación: se ha de garantizar quién es el otro extremo.
    \item Disuasión: se ha de evitar cualquier motivación para realizar ataques.
    \item No repudio: se ha de garantizar que la operación se realizó.
    \item Recuperación: se puede devolver el sistema su estado inicial tras un ataque.
\end{itemize}

\subsection{Cifrado simétrico y asimétrico}
La técnica de cifrado se emplea para garantizar la confidencialidad.
En líneas generales se basa en aplicar un algoritmo con una clave sobre un bloque de datos, denominado texto plano.
El resultado es otra representación del texto plano de manera que no se puede recuperar la información original sin conocer los detalles del cifrado.

Estos algoritmos se basan en operaciones de sustitución y transposición, reordenación de bloques de datos.
Se clasifican en dos tipos principalmente: simétricos y asimétricos.

El cifrado simétrico hace referencia a la existencia de una misma clave para cifrar y descifrar.
Esta clave la tienen que conocer los dos extremos para poder establecer una comunicación con éxito.
Algunos de los algoritmos más conocidos son \texttt{IDEA}, \texttt{3DES}, \texttt{AES} y \texttt{RC4}.

Sin embargo, no hace falta aplicar operaciones tan complejas cuando solo se desea ofuscar el texto, como sucede en los videojuegos.
En estos casos, la operación \texttt{XOR} sirve a este propósito (Tabla~\ref{tab:art-xor}).
El primer operando sería el byte a cifrar y el segundo un valor de clave.
Esta operación tiene el problema de que si se aplica sobre un byte con valor cero, el resultado será el segundo operando, es decir, la clave.
Otra desventaja es que, conociendo una sección del texto plano y teniendo el texto cifrado, el resultado de aplicar \texttt{XOR} entre ambos sería la clave.
Para evitar estos dos problemas, se usa una clave que cambia tras cada ejecución, de forma que mediante un conjunto de bytes nulos solo se recuperaría un estado temporal de la misma.

\ctable[
    caption = Tabla de resultados de la operación \texttt{XOR}.,
    label   = tab:art-xor,
    pos     = tb
]{ccc}{}{                                                                   \FL
    Primer operando & Segundo operando & Resultado                          \ML
    0               & 0                & 0                                  \NN
    0               & 1                & 1                                  \NN
    1               & 0                & 1                                  \NN
    1               & 1                & 0                                  \LL
}


El cifrado asimétrico, a pesar de ser más lento que el simétrico, soluciona el problema de compartir la misma clave usada para cifrar y descifrar.
De esta forma, cada extremo posee una clave y no necesita conocer la otra.
Un mensaje cifrado con la primera clave solo podría ser descifrado con la segunda, y viceversa.
Este tipo de algoritmo se usa en las comunicaciones a través de redes inseguras como Internet.
Cuando se genera el par de claves, una se suele mantener secreta (clave privada) y la otra se comparte entre varias entidades (clave pública).
El algoritmo más utilizado es \texttt{RSA}, que soporta tanto cifrado y descifrado como firma digital e intercambio de claves.

\subsection{Algoritmos para integridad}
Los algoritmos para integridad tienen como objetivo asegurar que el mensaje no ha sido modificado.
Para ello, mediante una serie de operaciones, se ofrece un resumen de tamaño fijo de los datos de entrada.
Los algoritmos deben cumplir que las colisiones (coincidencias de resumen entre dos bloques de datos distintos) sean no reproducibles.
Estos se clasifican por el número de bits del resultado, siendo los más frecuentes \texttt{MD5}\footnote{Este algoritmo es inseguro.}, con 128 bits, y \texttt{SHA-1}, con 160 bits.

\subsection{Firma digital}
La firma digital es una técnica para proveer tanto autenticidad como integridad sobre un mensaje.
Consiste en aplicar un algoritmo de integridad sobre un bloque de datos y, el resultado cifrarlo con la clave privada del emisor.
De esta forma, solo la clave pública correspondiente a esta entidad podrá descifrarlo, asegurando que ha sido esta quien ha realizado la operación.
Además, al tener el resumen se puede comprobar que el mensaje no ha sido modificado.
Lo frecuente es emplear \texttt{SHA-1} para la integridad y \texttt{RSA} para cifrar.

\section{Seguridad en videoconsolas}
\label{sec:art-video}
La seguridad cada vez más se confía en la consola, en lugar de sobre el propio juego.
El principal problema que esto genera es que una vez que esta protección se consigue romper, todos los juegos quedan expuestos.

A principios de la era de los videojuegos, la piratería era poco común, principalmente por la dificultad en encontrar el hardware necesario para romper los sistemas de protección.
Los juegos se distribuían en cartuchos de solo lectura, ya que no existían memorias se uso genérico como SD, ni protocolos de comunicación como USB.

Con la introducción de la \acl{NDS}, esto cambió.
Los juegos se distribuyen en pequeños cartuchos de tamaño similar a una tarjeta SD.
Debido a la existencia de tarjetas MicroSD, se pudieron crear dispositivos que simulan ser un juego comercial y que permiten ejecutar código no autorizado por Nintendo.
Estos se conocen como \textit{flashcards} y se basan en \textit{exploits} que consiguen saltarse las limitaciones del sistema de la consola para, simulando ser un juego, comenzar la ejecución de otro.

\subsection{\acl{NDS}}
En el caso de la \acl{NDS}, los juegos incorporan una lógica para transmitir, mediante un protocolo, datos cifrados a la consola~\cite{GbaTek}.
Este cifrado se basa en dos claves, la primera constante y la segunda generada en cada ejecución.
Se cifran los comandos enviados por la consola al cartucho y la respuesta con los datos del juego.
Aparte del cifrado, la \textit{BIOS} y \textit{firmware} realizan una comprobación sobre la cabecera del juego.
En concreto, hay una región donde se encuentra el logo de Nintendo ofuscado~\footnote{\url{http://pleonet.blogspot.com.es/2013/08/logo-de-nintendo-en-gba-y-nds.html}}.
El propósito es que, al contener datos con derechos de autor como es el logo de la compañía, los juegos no se podrían distribuir sin la autorización de Nintendo.
Un caso similar fue llevado a juicio en Estados Unidos, perdiendo Sony, la empresa que pretendía evitar estas actuaciones~\cite[p.~18]{RevBlack}.

El caso descrito sucedió con la consola Sega Genesis, cuando la empresa Accolade, en lugar de afiliarse con Sega para desarrollar juegos, decidió realizar ingeniería inversa y crear sus productos en base a esa información.
Esta compañía determinó que la palabra `SEGA' tenía que estar contenida en la cabecera del juego para hacerlo funcionar.
Sin embargo, esos caracteres están protegidos con \textit{copyright} por Sega y en base a esto, llevó a cabo una demanda.
Finalmente, la corte le dio la razón a Accolade ya que no había copiado código de Sega y beneficiaba al mercado introduciendo competencia.

\subsection{\acl{DSi}}
Un sistema más robusto se introdujo con la \acl{DSi}.
El formato de los juegos se mantiene pero, en aquellos juegos exclusivos para la nueva generación, se añade una firma digital usando la clave privada de Nintendo.
El sistema operativo de la consola comprueba la firma y, de ser inválida, el juego no se ejecuta.

Mediante este procedimiento, las \textit{flaschard} dejaron de funcionar.
No se podía ni generar una firma digital válida, ni utilizar una existente porque, al modificar el código del juego, la firma sería inválida.

El agujero de seguridad vino junto a las malas implementaciones de algunos juegos.
Modificando los archivos de guardado de ciertos juegos, se conseguía provocar un fallo del juego (\textit{buffer overflow}), de forma que el siguiente código que ejecutaba era el almacenado en el propio archivo de guardado.
Esto implica que distribuyendo un juego comercial con este fallo junto a una partida preparada para explotarlo, se podían crear \textit{flashcard} que ejecutasen cualquier código contenido en el archivo de la partida.

\subsection{\acl{N3DS}}
\label{sec:art-dev-3ds}
La siguiente generación de consolas de Nintendo aumentó más la seguridad.
Los juegos distribuidos vienen protegidos con un cifrado simétrico implementado sobre un módulo hardware de la consola.
Cuando se piden datos al cartucho, estos pasan por el módulo de descifrado de la consola y se almacenan en la memoria \texttt{RAM}.
Se trata de un módulo diseñado específicamente para la consola, encontrándose la clave sobre las pistas del chip, por lo que no se puede averiguar.

Para incrementar la seguridad se colocaron los componentes de la consola estratégicamente, de forma que era complicado extraer y acceder a la memoria \texttt{RAM}.
A pesar de ello, hubo personas que consiguieron acceder, pudiendo leer los datos descifrados del juego e incluso alterar las instrucciones almacenadas en la memoria para ejecutar código que forzara descifrar del juego completo.
Fue este, así, un proceso manual que permitió encontrar una serie de \textit{exploits}\footnote{\url{http://smealum.net/ninjhax/}} que se aprovechaban de nuevo de fallos de seguridad en los archivos de guardado para ejecutar código descifrado directamente.

\section{Ingeniería inversa}
% Definición de ingeniería inversa por REDO
\foreignquote{english}{\textit{\textbf{Reverse engineering} is the process of analyzing a subject system to identify the system's components and their inter-relationships, and to create representations of the system in another form or at higher levels of abstraction.}}

\foreignquote{spanish}{\textbf{La ingeniería inversa} es el proceso de analizar un sistema para identificar sus componentes y relaciones y, crear una representación del sistema en otro formato o a un nivel más alto de abstracción.}

Con estas palabras definió el compendio del proyecto europeo REDO en 1993 el término \textit{ingeniería inversa}~\cite[p.~17]{REDO}.
Se trata de un proyecto enmarcado dentro del plan \ac{ESPRIT}.
El trabajo realizado por 11 organizaciones de 7 países tenía como objetivo tratar el problema del mantenimiento de software mediante técnicas de ingeniería inversa.
Para ello se propusieron los siguientes objetivos:

\begin{enumerate}
    \item Validar el software existente.
    \item Acoplar el software y su documentación.
    \item Usar métodos formales en mantenimiento de software.
    \item Mejorar la usabilidad del software existente mediante mejores interfaces de usuario.
    \item Desarrollo y mejora de herramientas para reestructurar el código fuente y el control de trabajo.
    \item Desarrollo de un lenguaje genérico con el que se pueda expresar la semántica de diferentes lenguajes de programación y control de trabajo.
\end{enumerate}

% Objetivos de la ingeniería inversa por REDO
Este proyecto identificó dos tareas principales a la hora de realizar un trabajo de ingeniería inversa~\cite[p.~17]{REDO}:

\begin{itemize}
    \item \textit{Redocumentación}.
    Proceso por el que se crea una representación semánticamente equivalente con el mismo nivel de abstracción.
    En este trabajo se ha llevado a cabo mediante el desarrollo de ciertos programas que procesan ficheros de igual forma que lo hace un videojuego.

    \item \textit{Recuperación de diseño}.
    Proceso que involucra identificar el diseño en niveles más altos de abstracción que aquellos se que pudieran ver, examinando el sistema en sí.
    Esta tarea se ha llevado aquí documentando los algoritmos estudiados.
\end{itemize}

% Problema de descompilar
En proceso de desarrollo común es el de programar una aplicación en un lenguaje de alto nivel y, mediante un software denominado \textit{compilador}, convertir el texto escrito en una serie de bytes que el ordenador es capaz de interpretar para ejecutar operaciones a nivel de hardware.
La tarea de depuración, en el caso de la ingeniería inversa, trata sobre analizar esos bytes, instrucciones que el ordenador interpreta, y a partir de ellas entender el diseño original en alto nivel.
Existen programas llamados \textit{descompiladores} que automatizan esta tarea para diferentes lenguajes de programación, como por ejemplo, el que incluye \textit{IDA Pro} para convertir lenguaje ensamblador en lenguaje C.

La forma de evitar este proceso, aparte de aplicar cifrados a nivel de hardware como hace la \acl{N3DS} (Apartado~\ref{sec:art-dev-3ds}), es mediante ofuscación de código.
Este proceso consiste en transformar el código de forma que es menos legible, pero mantiene la funcionalidad~\cite[p.~344]{RevBlack}.
Debe de cumplir además que las transformaciones aplicadas no sean sencillas de revertir, de forma que no se pudiera crear un \textit{desofuscador} y que el sobrecoste que este proceso conlleva no afecte al rendimiento.
El nivel de complejidad que añade esta técnica se llama \textit{potencia}, y se puede medir con software convencional que toma en cuenta factores como el número de funciones y la profundidad de anidado que tiene una secuencia de código.

Un sistema podría considerarse seguro una vez que el esfuerzo y tiempo que requiere romper su seguridad es mayor al valor del producto y su validez.
Un ejemplo sería que el coste de distribuir copias no legales de un juego sea mayor al coste del mismo original, o que el tiempo empleado para averiguar una clave sea mayor a la frecuencia con la que el sistema la cambia.

En cuanto a la ingeniería inversa en videojuegos, no es distinta a los procedimientos seguidos sobre aplicaciones.
Esta se centra más sobre los recursos y sus formatos que en el código y funcionalidad\footnote{En la siguiente dirección se encuentra una guía de introducción a la ingeniería inversa para \acl{NDS}:

\url{http://gbatemp.net/threads/gbatemp-rom-hacking-documentation-project-new-2014-edition-out.73394/}}.

\subsection{Legalidad}
La ingeniería inversa no está exenta de controversia a la hora de determinar su legalidad.
El punto 14 de la \textit{directiva 2009/24/CE sobre la protección jurídica de programas de ordenador}\footnote{\url{http://eur-lex.europa.eu/legal-content/ES/TXT/PDF/?uri=CELEX:32009L0024&from=EN}} dice:

\enquote{No debe impedirse a la persona facultada para utilizar el programa de ordenador que realice los actos necesarios para observar, estudiar o verificar su funcionamiento, siempre que dichos actos no supongan infracción de los derechos del autor sobre el programa.}

Es decir, siempre que se posean los derechos de acceder a un contenido, no se debe prohibir el derecho a estudiar este.
Sin embargo, las directivas europeas son recomendaciones que los países miembros implementan con sus propias leyes.
En el caso de España, se recoge en número 97 del BOE\footnote{\url{http://boe.es/buscar/act.php?id=BOE-A-1996-8930&tn=1&p=19980307&vd=\#a100}} en el título VII, \textit{Programas de ordenador}, artículo 100, \textit{límites a los derechos de explotación}:

\enquote{El usuario legítimo de la copia de un programa estará facultado para observar, estudiar o verificar su funcionamiento, sin autorización previa del titular, con el fin de determinar las ideas y principios implícitos en cualquier elemento del programa, siempre que lo haga durante cualquiera de las operaciones de carga, visualización, ejecución, transmisión o almacenamiento del programa que tiene derecho a hacer.}

\noindent donde se recoge el mismo contenido que la directiva europea recomienda.
Esto, además, está respaldado por la resolución de un juicio en la Corte Suprema de la Unión Europa en esta materia\footnote{\url{http://www.bloomberg.com/news/articles/2012-05-02/copyright-can-t-block-software-reverse-engineering-court}}.
En ella, la compañía \textit{World Programming Ltd} fue demandada por \textit{SaaS Institute Inc.} al desarrollar un software a partir de conocimientos adquiridos mediante ingeniería inversa, que replicaba el funcionamiento del programa de la compañía demandante. La corte señaló que `\textit{There is no copyright infringement [when a software company without access to a program's source code] studied, observed and tested that program in order to reproduce its functionality in a second program. (No se infringe el copyright [cuando una compañía de software sin acceso al código fuente del programa] estudia, observa y prueba el problema para reproducir su funcionalidad en un segundo programa)}'.

En el caso de Estados Unidos, la ley \ac{DMCA} lo prohíbe a no ser que se cuente con el permiso del autor.
El Capítulo 12 del libro \textit{Hacking the Xbox}, escrito por Lee Tien, abogado de la \ac{EFF}, contiene un completo análisis al respecto.
Incluye una cita de la Corte Suprema americana, refiriéndose a la ingeniería inversa como \textit{una parte esencial de la innovación}~\cite[p.~180]{Xbox}.
